/*
THIS IS A GENERATED/BUNDLED FILE BY ESBUILD
if you want to view the source, please visit the github repository of this plugin
*/

var __defProp = Object.defineProperty;
var __getOwnPropDesc = Object.getOwnPropertyDescriptor;
var __getOwnPropNames = Object.getOwnPropertyNames;
var __hasOwnProp = Object.prototype.hasOwnProperty;
var __export = (target, all) => {
  for (var name in all)
    __defProp(target, name, { get: all[name], enumerable: true });
};
var __copyProps = (to, from, except, desc) => {
  if (from && typeof from === "object" || typeof from === "function") {
    for (let key of __getOwnPropNames(from))
      if (!__hasOwnProp.call(to, key) && key !== except)
        __defProp(to, key, { get: () => from[key], enumerable: !(desc = __getOwnPropDesc(from, key)) || desc.enumerable });
  }
  return to;
};
var __toCommonJS = (mod) => __copyProps(__defProp({}, "__esModule", { value: true }), mod);

// src/main.ts
var main_exports = {};
__export(main_exports, {
  default: () => CustomClassPlugin
});
module.exports = __toCommonJS(main_exports);
var import_obsidian2 = require("obsidian");

// src/editorExtension.ts
var import_view = require("@codemirror/view");
var import_state = require("@codemirror/state");
var PATTERNS = {
  // # Header ::: class
  HEADER: /^(#{1,6})\s+(.+?)\s+(:::\s*[\w-]+(?:\s*:\s*[\w-]+)*)\s*$/,
  // - item ::: class or - [ ] item ::: class
  LIST_ITEM: /^(\s*[-*+])\s+(?:\[[ xX]\]\s+)?(.+?)\s+(:::\s*[\w-]+(?:\s*:\s*[\w-]+)*)\s*$/,
  // > [!type] Title ::: class
  CALLOUT: /^>\s*\[!\w+\](.*?)\s+(:::\s*[\w-]+(?:\s*:\s*[\w-]+)*)\s*$/,
  // ```lang ::: class
  CODE_BLOCK: /^```(\w*)\s*(.*?)\s*(:::\s*[\w-]+(?:\s*:\s*[\w-]+)*)\s*$/,
  // ::: class (block start)
  BLOCK_START: /^:::\s*([\w-]+(?:\s*:\s*[\w-]+)*)\s*$/,
  // ::: (block end)
  BLOCK_END: /^:::\s*$/
};
var markerDecoration = import_view.Decoration.mark({ class: "ccs-syntax-marker" });
var classDecoration = import_view.Decoration.mark({ class: "ccs-class-name" });
var escapedDecoration = import_view.Decoration.mark({ class: "ccs-escaped" });
function isEscapedAt(text, position) {
  if (position <= 0) return false;
  let count = 0;
  let i = position - 1;
  while (i >= 0 && text[i] === "\\") {
    count++;
    i--;
  }
  return count % 2 === 1;
}
function buildDecorations(view) {
  const builder = new import_state.RangeSetBuilder();
  const doc = view.state.doc;
  const text = doc.toString();
  const lines = text.split("\n");
  const decorations = [];
  let lineOffset = 0;
  let inCodeBlock = false;
  for (let i = 0; i < lines.length; i++) {
    const line = lines[i];
    const lineStart = lineOffset;
    const lineEnd = lineOffset + line.length;
    if (line.trim().startsWith("```")) {
      if (!inCodeBlock) {
        inCodeBlock = true;
        const match = line.match(PATTERNS.CODE_BLOCK);
        if (match) {
          const markerStart = line.lastIndexOf(":::");
          if (markerStart !== -1 && !isEscapedAt(line, markerStart)) {
            decorations.push({
              from: lineStart + markerStart,
              to: lineStart + markerStart + 3,
              decoration: markerDecoration
            });
            const classStart = markerStart + 3;
            const classEnd = line.length;
            if (classEnd > classStart) {
              decorations.push({
                from: lineStart + classStart,
                to: lineStart + classEnd,
                decoration: classDecoration
              });
            }
          }
        }
      } else {
        inCodeBlock = false;
      }
      lineOffset = lineEnd + 1;
      continue;
    }
    if (inCodeBlock) {
      lineOffset = lineEnd + 1;
      continue;
    }
    const escapedMatch = line.match(/\\:::/g);
    if (escapedMatch) {
      let pos = 0;
      while (pos < line.length) {
        const idx = line.indexOf("\\:::", pos);
        if (idx === -1) break;
        decorations.push({
          from: lineStart + idx,
          to: lineStart + idx + 4,
          decoration: escapedDecoration
        });
        pos = idx + 4;
      }
    }
    const trimmed = line.trim();
    if (PATTERNS.BLOCK_START.test(trimmed)) {
      const markerStart = line.indexOf(":::");
      if (markerStart !== -1 && !isEscapedAt(line, markerStart)) {
        decorations.push({
          from: lineStart + markerStart,
          to: lineStart + markerStart + 3,
          decoration: markerDecoration
        });
        const afterMarker = markerStart + 3;
        const classEnd = line.trimEnd().length;
        if (classEnd > afterMarker) {
          decorations.push({
            from: lineStart + afterMarker,
            to: lineStart + classEnd,
            decoration: classDecoration
          });
        }
      }
    } else if (PATTERNS.BLOCK_END.test(trimmed)) {
      const markerStart = line.indexOf(":::");
      if (markerStart !== -1 && !isEscapedAt(line, markerStart)) {
        decorations.push({
          from: lineStart + markerStart,
          to: lineStart + markerStart + 3,
          decoration: markerDecoration
        });
      }
    }
    for (const pattern of [PATTERNS.HEADER, PATTERNS.LIST_ITEM, PATTERNS.CALLOUT]) {
      const match = line.match(pattern);
      if (match) {
        const markerStart = line.lastIndexOf(":::");
        if (markerStart !== -1 && !isEscapedAt(line, markerStart)) {
          decorations.push({
            from: lineStart + markerStart,
            to: lineStart + markerStart + 3,
            decoration: markerDecoration
          });
          const classStart = markerStart + 3;
          const classEnd = line.trimEnd().length;
          if (classEnd > classStart) {
            decorations.push({
              from: lineStart + classStart,
              to: lineStart + classEnd,
              decoration: classDecoration
            });
          }
        }
        break;
      }
    }
    const inlineCodeRegex = /`[^`]+`\s*:::\s*[\w-]+(?:\s*:\s*[\w-]+)*/g;
    let inlineMatch;
    while ((inlineMatch = inlineCodeRegex.exec(line)) !== null) {
      const markerPos = inlineMatch[0].indexOf(":::");
      const globalPos = inlineMatch.index + markerPos;
      if (!isEscapedAt(line, globalPos)) {
        decorations.push({
          from: lineStart + globalPos,
          to: lineStart + inlineMatch.index + inlineMatch[0].length,
          decoration: markerDecoration
        });
      }
    }
    const inlineTextRegex = /:::(.+?):::/g;
    while ((inlineMatch = inlineTextRegex.exec(line)) !== null) {
      if (isEscapedAt(line, inlineMatch.index)) continue;
      decorations.push({
        from: lineStart + inlineMatch.index,
        to: lineStart + inlineMatch.index + 3,
        decoration: markerDecoration
      });
      const inner = inlineMatch[1];
      const lastColon = inner.lastIndexOf(":");
      if (lastColon > 0) {
        const classEnd = inlineMatch.index + 3 + lastColon;
        decorations.push({
          from: lineStart + inlineMatch.index + 3,
          to: lineStart + classEnd,
          decoration: classDecoration
        });
      }
      decorations.push({
        from: lineStart + inlineMatch.index + inlineMatch[0].length - 3,
        to: lineStart + inlineMatch.index + inlineMatch[0].length,
        decoration: markerDecoration
      });
    }
    lineOffset = lineEnd + 1;
  }
  decorations.sort((a, b) => a.from - b.from || a.to - b.to);
  let lastEnd = -1;
  for (const dec of decorations) {
    if (dec.from >= lastEnd && dec.from >= 0 && dec.to > dec.from && dec.to <= text.length) {
      builder.add(dec.from, dec.to, dec.decoration);
      lastEnd = dec.to;
    }
  }
  return builder.finish();
}
var decorationPlugin = import_view.ViewPlugin.fromClass(
  class {
    constructor(view) {
      this.decorations = buildDecorations(view);
    }
    update(update) {
      if (update.docChanged || update.viewportChanged) {
        this.decorations = buildDecorations(update.view);
      }
    }
  },
  {
    decorations: (v) => v.decorations
  }
);
var decorationTheme = import_view.EditorView.baseTheme({
  ".ccs-syntax-marker": {
    color: "var(--text-faint)",
    fontFamily: "var(--font-monospace)",
    fontSize: "0.9em"
  },
  ".ccs-class-name": {
    color: "var(--color-cyan)",
    fontFamily: "var(--font-monospace)",
    backgroundColor: "var(--background-modifier-code)",
    borderRadius: "3px",
    padding: "0 3px"
  },
  ".ccs-escaped": {
    color: "var(--text-muted)",
    opacity: "0.6"
  }
});
function createEditorExtension() {
  return [decorationPlugin, decorationTheme];
}

// src/parser.ts
function parseClasses(classString) {
  if (!classString) return [];
  return classString.split(":").map((c) => c.trim().replace(/^\./, "")).filter((c) => c.length > 0 && isValidClassName(c));
}
function isValidClassName(name) {
  return /^[a-zA-Z_-][a-zA-Z0-9_-]*$/.test(name);
}
function isEscapedAt2(text, position) {
  if (position <= 0) return false;
  let backslashCount = 0;
  let i = position - 1;
  while (i >= 0 && text[i] === "\\") {
    backslashCount++;
    i--;
  }
  return backslashCount % 2 === 1;
}
function findUnescapedMarker(text, startFrom = 0) {
  let pos = startFrom;
  while (pos < text.length) {
    const idx = text.indexOf(":::", pos);
    if (idx === -1) return -1;
    if (!isEscapedAt2(text, idx)) {
      return idx;
    }
    pos = idx + 3;
  }
  return -1;
}
function parseSource(text) {
  const lines = text.split("\n");
  const lineInfo = /* @__PURE__ */ new Map();
  const blocks = [];
  const codeBlockLines = /* @__PURE__ */ new Set();
  let inCodeBlock = false;
  let codeBlockStartLine = -1;
  let currentBlock = null;
  for (let i = 0; i < lines.length; i++) {
    const line = lines[i];
    const trimmedLine = line.trim();
    if (trimmedLine.startsWith("```")) {
      if (!inCodeBlock) {
        inCodeBlock = true;
        codeBlockStartLine = i;
        const markerPos = findUnescapedMarker(trimmedLine);
        if (markerPos !== -1) {
          const afterMarker = trimmedLine.slice(markerPos + 3).trim();
          const classes = parseClasses(afterMarker);
          if (classes.length > 0) {
            lineInfo.set(i, { type: "code-block", classes });
          }
        }
      } else {
        inCodeBlock = false;
        for (let j = codeBlockStartLine; j <= i; j++) {
          codeBlockLines.add(j);
        }
      }
      continue;
    }
    if (inCodeBlock) continue;
    if (/^:::\s*$/.test(trimmedLine) && currentBlock) {
      blocks.push({
        startLine: currentBlock.startLine,
        endLine: i,
        classes: currentBlock.classes,
        type: currentBlock.type
      });
      lineInfo.set(i, { type: "block-end", classes: currentBlock.classes });
      currentBlock = null;
      continue;
    }
    const blockStartMatch = trimmedLine.match(/^:::\s*([\w-]+(?:\s*:\s*[\w-]+)*)\s*$/);
    if (blockStartMatch && !currentBlock) {
      const classes = parseClasses(blockStartMatch[1]);
      if (classes.length > 0) {
        let blockType = "general";
        for (let j = i + 1; j < lines.length; j++) {
          const nextLine = lines[j].trim();
          if (!nextLine) continue;
          if (nextLine.startsWith("|")) {
            blockType = "table";
            break;
          }
          if (/^[-*+]\s/.test(nextLine) || /^\d+\.\s/.test(nextLine)) {
            blockType = "list";
            break;
          }
          if (nextLine.startsWith(":::")) break;
          break;
        }
        currentBlock = { startLine: i, classes, type: blockType };
        lineInfo.set(i, { type: "block-start", classes });
      }
      continue;
    }
    if (currentBlock) {
      lineInfo.set(i, { type: "block-content", classes: currentBlock.classes });
      continue;
    }
    const headerMatch = trimmedLine.match(/^(#{1,6})\s+(.+?)\s+:::\s*([\w-]+(?:\s*:\s*[\w-]+)*)\s*$/);
    if (headerMatch && findUnescapedMarker(trimmedLine) !== -1) {
      const classes = parseClasses(headerMatch[3]);
      if (classes.length > 0) {
        lineInfo.set(i, { type: "header", classes, contentWithoutMarker: headerMatch[2].trim() });
      }
      continue;
    }
    const calloutMatch = trimmedLine.match(/^>\s*\[!(\w+)\](.*?)\s*:::\s*([\w-]+(?:\s*:\s*[\w-]+)*)\s*$/);
    if (calloutMatch && findUnescapedMarker(trimmedLine) !== -1) {
      const classes = parseClasses(calloutMatch[3]);
      if (classes.length > 0) {
        lineInfo.set(i, { type: "callout", classes, contentWithoutMarker: calloutMatch[2].trim() });
      }
      continue;
    }
  }
  return { lineInfo, blocks, codeBlockLines };
}
function parseInlineText(text) {
  const matches = [];
  const regex = /:::(.+?):::/g;
  let match;
  while ((match = regex.exec(text)) !== null) {
    if (isEscapedAt2(text, match.index)) continue;
    const closePos = match.index + match[0].length - 3;
    if (isEscapedAt2(text, closePos)) continue;
    const inner = match[1].trim();
    const lastColonIndex = inner.lastIndexOf(":");
    if (lastColonIndex === -1) continue;
    const classesStr = inner.slice(0, lastColonIndex).trim();
    const content = inner.slice(lastColonIndex + 1).trim();
    if (!content || !classesStr) continue;
    const classes = parseClasses(classesStr);
    if (classes.length > 0) {
      matches.push({ start: match.index, end: match.index + match[0].length, classes, content });
    }
  }
  return matches;
}
function unescapeText(text) {
  return text.replace(/\\:::/g, ":::");
}

// src/postProcessor.ts
function getCleanText(el) {
  const clone = el.cloneNode(true);
  clone.querySelectorAll("svg, .collapse-indicator, .heading-collapse-indicator, .list-bullet, input").forEach((e) => e.remove());
  return clone.textContent || "";
}
function removeMarkerFromElement(el) {
  const walker = document.createTreeWalker(el, NodeFilter.SHOW_TEXT);
  const textNodes = [];
  let node;
  while (node = walker.nextNode()) {
    textNodes.push(node);
  }
  for (const textNode of textNodes) {
    const text = textNode.textContent || "";
    const newText = text.replace(/\s*:::\s*[\w\s:.-]*$/, "").replace(/^\s*:::\s*$/, "");
    if (newText !== text) {
      textNode.textContent = newText;
    }
  }
  const brs = el.querySelectorAll("br");
  brs.forEach((br) => {
    var _a;
    const next = br.nextSibling;
    if ((next == null ? void 0 : next.nodeType) === Node.TEXT_NODE) {
      const nextText = ((_a = next.textContent) == null ? void 0 : _a.trim()) || "";
      if (nextText === ":::" || nextText === "") {
        next.textContent = "";
      }
    }
  });
}
function extractClassesFromText(text) {
  const match = text.match(/:::\s*([\w-]+(?:\s*:\s*[\w-]+)*)\s*$/);
  if (match) {
    return parseClasses(match[1]);
  }
  return null;
}
var CustomClassPostProcessor = class {
  constructor(component) {
    this.component = component;
  }
  process(el, ctx) {
    const info = ctx.getSectionInfo(el);
    if (info) {
      const { text, lineStart, lineEnd } = info;
      const parseResult = parseSource(text);
      if (parseResult.codeBlockLines.has(lineStart)) {
        return;
      }
      this.processWithSource(el, lineStart, lineEnd, parseResult, text);
    }
    this.processListItems(el);
    this.processInlines(el);
    this.cleanupBlockMarkers(el);
    this.unescapeMarkers(el);
  }
  /**
   * Process element based on source line info
   */
  processWithSource(el, lineStart, lineEnd, result, fullText) {
    const lineInfo = result.lineInfo.get(lineStart);
    for (const block of result.blocks) {
      if (lineStart >= block.startLine && lineEnd <= block.endLine) {
        this.applyBlockContentClasses(el, block, lineStart === block.startLine, lineEnd >= block.endLine);
        return;
      }
    }
    if (!lineInfo) return;
    switch (lineInfo.type) {
      case "header":
        this.processHeader(el, lineInfo);
        break;
      case "callout":
        this.processCallout(el, lineInfo);
        break;
      case "code-block":
        this.processCodeBlock(el, lineInfo);
        break;
      case "block-start":
        this.hideMarker(el);
        el.setAttribute("data-ccs-block-start", lineInfo.classes.join(" "));
        break;
      case "block-end":
        this.hideMarker(el);
        break;
    }
  }
  /**
   * Process all list items in the element (DOM-based)
   */
  processListItems(el) {
    const listItems = el.querySelectorAll("li");
    listItems.forEach((li) => {
      if (li.hasAttribute("data-ccs-processed")) return;
      const text = getCleanText(li);
      const classes = extractClassesFromText(text);
      if (classes && classes.length > 0) {
        li.classList.add(...classes);
        li.setAttribute("data-ccs-processed", "true");
        removeMarkerFromElement(li);
      }
    });
  }
  /**
   * Process header: # Header ::: class
   */
  processHeader(el, info) {
    const header = el.querySelector("h1, h2, h3, h4, h5, h6");
    if (header) {
      header.classList.add(...info.classes);
      removeMarkerFromElement(header);
    }
  }
  /**
   * Process callout: > [!type] Title ::: class
   */
  processCallout(el, info) {
    const callout = el.querySelector(".callout");
    if (callout) {
      callout.classList.add(...info.classes);
      const titleInner = callout.querySelector(".callout-title-inner");
      if (titleInner) {
        removeMarkerFromElement(titleInner);
      }
    }
  }
  /**
   * Process code block: ```lang ::: class
   */
  processCodeBlock(el, info) {
    const pre = el.querySelector("pre");
    if (pre) {
      pre.classList.add(...info.classes);
    }
  }
  /**
   * Hide block marker elements
   */
  hideMarker(el) {
    el.style.display = "none";
    el.classList.add("ccs-marker");
  }
  /**
   * Apply classes to content inside a block
   */
  applyBlockContentClasses(el, block, isStart, containsEnd) {
    if (isStart) {
      this.hideMarker(el);
      el.setAttribute("data-ccs-block-start", block.classes.join(" "));
      return;
    }
    switch (block.type) {
      case "table":
        const table = el.querySelector("table");
        if (table) {
          table.classList.add(...block.classes);
        }
        break;
      case "list":
        const list = el.querySelector("ul, ol");
        if (list) {
          list.classList.add(...block.classes);
        }
        break;
      default:
        el.classList.add(...block.classes);
    }
    if (containsEnd) {
      this.removeBlockEndMarker(el);
    }
  }
  /**
   * Remove block end marker from element content
   */
  removeBlockEndMarker(el) {
    const walker = document.createTreeWalker(el, NodeFilter.SHOW_TEXT);
    const textNodes = [];
    let node;
    while (node = walker.nextNode()) {
      textNodes.push(node);
    }
    for (let i = textNodes.length - 1; i >= 0; i--) {
      const textNode = textNodes[i];
      const text = textNode.textContent || "";
      if (/^\s*:::\s*$/.test(text)) {
        textNode.textContent = "";
        const prev = textNode.previousSibling;
        if ((prev == null ? void 0 : prev.nodeName) === "BR") {
          prev.remove();
        }
        break;
      }
      if (text.includes(":::")) {
        textNode.textContent = text.replace(/\s*:::\s*$/, "");
        break;
      }
    }
  }
  /**
   * Clean up any remaining block markers
   */
  cleanupBlockMarkers(el) {
    if (el.classList.contains("ccs-marker")) return;
    const walker = document.createTreeWalker(el, NodeFilter.SHOW_TEXT);
    const textNodes = [];
    let node;
    while (node = walker.nextNode()) {
      textNodes.push(node);
    }
    for (const textNode of textNodes) {
      const text = textNode.textContent || "";
      if (/^\s*:::\s*$/.test(text.trim())) {
        const parent = textNode.parentElement;
        if (parent && !parent.closest(".ccs-inline")) {
          textNode.textContent = "";
          const prev = textNode.previousSibling;
          if ((prev == null ? void 0 : prev.nodeName) === "BR") {
            prev.remove();
          }
        }
      }
    }
  }
  /**
   * Process inline syntax
   */
  processInlines(el) {
    if (el.classList.contains("ccs-marker")) return;
    this.processInlineCode(el);
    this.processInlineText(el);
  }
  /**
   * Process inline code with classes
   */
  processInlineCode(el) {
    const codeElements = el.querySelectorAll("code:not(pre code)");
    codeElements.forEach((code) => {
      const nextSibling = code.nextSibling;
      if ((nextSibling == null ? void 0 : nextSibling.nodeType) !== Node.TEXT_NODE) return;
      const text = nextSibling.textContent || "";
      const match = text.match(/^\s*:::\s*([\w-]+(?:\s*:\s*[\w-]+)*)/);
      if (!match) return;
      if (text.trimStart().startsWith("\\:::")) return;
      const classes = parseClasses(match[1]);
      if (classes.length > 0) {
        code.classList.add(...classes);
        nextSibling.textContent = text.slice(match[0].length);
      }
    });
  }
  /**
   * Process inline text syntax: ::: class : content :::
   */
  processInlineText(el) {
    const walker = document.createTreeWalker(
      el,
      NodeFilter.SHOW_TEXT,
      {
        acceptNode: (node2) => {
          const text = node2.textContent || "";
          const parent = node2.parentElement;
          if (!text.includes(":::")) return NodeFilter.FILTER_SKIP;
          if (parent == null ? void 0 : parent.closest(".ccs-inline, .ccs-marker, code, pre, svg")) {
            return NodeFilter.FILTER_SKIP;
          }
          return NodeFilter.FILTER_ACCEPT;
        }
      }
    );
    const textNodes = [];
    let node;
    while (node = walker.nextNode()) {
      textNodes.push(node);
    }
    for (const textNode of textNodes) {
      const text = textNode.textContent || "";
      const matches = parseInlineText(text);
      if (matches.length === 0) continue;
      const parent = textNode.parentNode;
      if (!parent) continue;
      const fragment = document.createDocumentFragment();
      let lastIndex = 0;
      for (const match of matches) {
        if (match.start > lastIndex) {
          fragment.appendChild(document.createTextNode(text.slice(lastIndex, match.start)));
        }
        const span = document.createElement("span");
        span.className = ["ccs-inline", ...match.classes].join(" ");
        span.textContent = match.content;
        fragment.appendChild(span);
        lastIndex = match.end;
      }
      if (lastIndex < text.length) {
        fragment.appendChild(document.createTextNode(text.slice(lastIndex)));
      }
      parent.replaceChild(fragment, textNode);
    }
  }
  /**
   * Unescape \::: markers
   */
  unescapeMarkers(el) {
    var _a;
    const walker = document.createTreeWalker(el, NodeFilter.SHOW_TEXT);
    const nodesToClean = [];
    let node;
    while (node = walker.nextNode()) {
      if ((_a = node.textContent) == null ? void 0 : _a.includes("\\:::")) {
        nodesToClean.push(node);
      }
    }
    nodesToClean.forEach((textNode) => {
      textNode.textContent = unescapeText(textNode.textContent || "");
    });
  }
};
function createPostProcessor(component) {
  const processor = new CustomClassPostProcessor(component);
  return (el, ctx) => {
    processor.process(el, ctx);
  };
}

// src/settings.ts
var import_obsidian = require("obsidian");
var DEFAULT_SETTINGS = {
  enableLivePreview: true,
  enableReadingView: true,
  showClassLabels: true,
  customCSS: ""
};
var CustomClassSettingTab = class extends import_obsidian.PluginSettingTab {
  constructor(app, plugin) {
    super(app, plugin);
    this.plugin = plugin;
  }
  display() {
    const { containerEl } = this;
    containerEl.empty();
    containerEl.createEl("h2", { text: "Custom Class Syntax Settings" });
    containerEl.createEl("h3", { text: "Syntax Reference" });
    const syntaxRef = containerEl.createDiv({ cls: "ccs-syntax-reference" });
    syntaxRef.innerHTML = `
      <div style="background: var(--background-secondary); padding: 1em; border-radius: 8px; margin-bottom: 1em;">
        <h4 style="margin-top: 0;">Block Syntax</h4>
        <pre style="background: var(--background-primary); padding: 0.5em; border-radius: 4px;">
::: warning
This content gets the "warning" class
:::

::: card : shadow : rounded
Multiple classes separated by colons
:::</pre>
        
        <h4>Inline Syntax</h4>
        <pre style="background: var(--background-primary); padding: 0.5em; border-radius: 4px;">
This is ::: .highlight : highlighted text ::: in a sentence.
Use ::: red : bold : important text ::: for emphasis.</pre>
        
        <h4>Escaping</h4>
        <pre style="background: var(--background-primary); padding: 0.5em; border-radius: 4px;">
\\::: This won't be parsed :::</pre>
      </div>
    `;
    new import_obsidian.Setting(containerEl).setName("Enable in Live Preview").setDesc("Show decorations in the editor").addToggle(
      (toggle) => toggle.setValue(this.plugin.settings.enableLivePreview).onChange(async (value) => {
        this.plugin.settings.enableLivePreview = value;
        await this.plugin.saveSettings();
      })
    );
    new import_obsidian.Setting(containerEl).setName("Enable in Reading View").setDesc("Process custom classes in reading view and PDF export").addToggle(
      (toggle) => toggle.setValue(this.plugin.settings.enableReadingView).onChange(async (value) => {
        this.plugin.settings.enableReadingView = value;
        await this.plugin.saveSettings();
      })
    );
    new import_obsidian.Setting(containerEl).setName("Show Class Labels").setDesc("Display class names above block elements").addToggle(
      (toggle) => toggle.setValue(this.plugin.settings.showClassLabels).onChange(async (value) => {
        this.plugin.settings.showClassLabels = value;
        await this.plugin.saveSettings();
        this.plugin.updateStyles();
      })
    );
    containerEl.createEl("h3", { text: "Custom CSS" });
    new import_obsidian.Setting(containerEl).setName("Additional CSS").setDesc("Add custom CSS for your classes (also applies to PDF export)").addTextArea((text) => {
      text.setPlaceholder(".my-class { color: red; }").setValue(this.plugin.settings.customCSS).onChange(async (value) => {
        this.plugin.settings.customCSS = value;
        await this.plugin.saveSettings();
        this.plugin.updateStyles();
      });
      text.inputEl.rows = 10;
      text.inputEl.style.width = "100%";
      text.inputEl.style.fontFamily = "var(--font-monospace)";
    });
    containerEl.createEl("h3", { text: "Built-in Classes" });
    const classRef = containerEl.createDiv();
    classRef.innerHTML = `
      <div style="background: var(--background-secondary); padding: 1em; border-radius: 8px; columns: 2; column-gap: 2em;">
        <div style="break-inside: avoid;">
          <h4 style="margin-top: 0;">Colors</h4>
          <code>red, green, blue, yellow, orange, purple, pink, cyan</code>
        </div>
        <div style="break-inside: avoid;">
          <h4>Backgrounds</h4>
          <code>bg-red, bg-green, bg-blue, bg-yellow, bg-orange, bg-purple</code>
        </div>
        <div style="break-inside: avoid;">
          <h4>Callouts</h4>
          <code>warning, danger, success, info, note, tip</code>
        </div>
        <div style="break-inside: avoid;">
          <h4>Typography</h4>
          <code>bold, italic, underline, strike, uppercase, lowercase</code>
        </div>
        <div style="break-inside: avoid;">
          <h4>Sizes</h4>
          <code>text-xs, text-sm, text-lg, text-xl, text-2xl, text-3xl</code>
        </div>
        <div style="break-inside: avoid;">
          <h4>Highlights</h4>
          <code>highlight, highlight-blue, highlight-green, highlight-pink</code>
        </div>
        <div style="break-inside: avoid;">
          <h4>Cards</h4>
          <code>card, shadow, shadow-lg, rounded, rounded-lg</code>
        </div>
        <div style="break-inside: avoid;">
          <h4>Layout</h4>
          <code>text-left, text-center, text-right, columns-2, columns-3</code>
        </div>
      </div>
    `;
  }
};

// src/main.ts
var CustomClassPlugin = class extends import_obsidian2.Plugin {
  constructor() {
    super(...arguments);
    this.styleEl = null;
  }
  async onload() {
    console.log("Loading Custom Class Syntax plugin");
    await this.loadSettings();
    this.addSettingTab(new CustomClassSettingTab(this.app, this));
    this.registerMarkdownPostProcessor(createPostProcessor(this));
    if (this.settings.enableLivePreview) {
      this.registerEditorExtension(this.getEditorExtensions());
    }
    this.injectStyles();
  }
  onunload() {
    console.log("Unloading Custom Class Syntax plugin");
    this.removeStyles();
  }
  async loadSettings() {
    this.settings = Object.assign({}, DEFAULT_SETTINGS, await this.loadData());
  }
  async saveSettings() {
    await this.saveData(this.settings);
  }
  getEditorExtensions() {
    return [createEditorExtension()];
  }
  injectStyles() {
    this.styleEl = document.createElement("style");
    this.styleEl.id = "custom-class-syntax-styles";
    this.updateStyleContent();
    document.head.appendChild(this.styleEl);
  }
  updateStyleContent() {
    if (!this.styleEl) return;
    let css = "";
    if (!this.settings.showClassLabels) {
      css += `.ccs-block::before { display: none !important; }`;
    }
    if (this.settings.customCSS) {
      css += `
/* User Custom CSS */
${this.settings.customCSS}`;
    }
    this.styleEl.textContent = css;
  }
  updateStyles() {
    this.updateStyleContent();
  }
  removeStyles() {
    var _a;
    (_a = this.styleEl) == null ? void 0 : _a.remove();
    this.styleEl = null;
  }
};
//# sourceMappingURL=data:application/json;base64,ewogICJ2ZXJzaW9uIjogMywKICAic291cmNlcyI6IFsic3JjL21haW4udHMiLCAic3JjL2VkaXRvckV4dGVuc2lvbi50cyIsICJzcmMvcGFyc2VyLnRzIiwgInNyYy9wb3N0UHJvY2Vzc29yLnRzIiwgInNyYy9zZXR0aW5ncy50cyJdLAogICJzb3VyY2VzQ29udGVudCI6IFsiLyoqXHJcbiAqIEN1c3RvbSBDbGFzcyBTeW50YXggUGx1Z2luIGZvciBPYnNpZGlhblxyXG4gKi9cclxuXHJcbmltcG9ydCB7IFBsdWdpbiB9IGZyb20gJ29ic2lkaWFuJztcclxuaW1wb3J0IHsgRXh0ZW5zaW9uIH0gZnJvbSAnQGNvZGVtaXJyb3Ivc3RhdGUnO1xyXG5pbXBvcnQgeyBjcmVhdGVFZGl0b3JFeHRlbnNpb24gfSBmcm9tICcuL2VkaXRvckV4dGVuc2lvbic7XHJcbmltcG9ydCB7IGNyZWF0ZVBvc3RQcm9jZXNzb3IgfSBmcm9tICcuL3Bvc3RQcm9jZXNzb3InO1xyXG5pbXBvcnQge1xyXG4gIEN1c3RvbUNsYXNzU2V0dGluZ3MsXHJcbiAgREVGQVVMVF9TRVRUSU5HUyxcclxuICBDdXN0b21DbGFzc1NldHRpbmdUYWIsXHJcbn0gZnJvbSAnLi9zZXR0aW5ncyc7XHJcblxyXG5leHBvcnQgZGVmYXVsdCBjbGFzcyBDdXN0b21DbGFzc1BsdWdpbiBleHRlbmRzIFBsdWdpbiB7XHJcbiAgc2V0dGluZ3M6IEN1c3RvbUNsYXNzU2V0dGluZ3M7XHJcbiAgcHJpdmF0ZSBzdHlsZUVsOiBIVE1MU3R5bGVFbGVtZW50IHwgbnVsbCA9IG51bGw7XHJcblxyXG4gIGFzeW5jIG9ubG9hZCgpIHtcclxuICAgIGNvbnNvbGUubG9nKCdMb2FkaW5nIEN1c3RvbSBDbGFzcyBTeW50YXggcGx1Z2luJyk7XHJcblxyXG4gICAgYXdhaXQgdGhpcy5sb2FkU2V0dGluZ3MoKTtcclxuXHJcbiAgICB0aGlzLmFkZFNldHRpbmdUYWIobmV3IEN1c3RvbUNsYXNzU2V0dGluZ1RhYih0aGlzLmFwcCwgdGhpcykpO1xyXG5cclxuICAgIHRoaXMucmVnaXN0ZXJNYXJrZG93blBvc3RQcm9jZXNzb3IoY3JlYXRlUG9zdFByb2Nlc3Nvcih0aGlzKSk7XHJcblxyXG4gICAgaWYgKHRoaXMuc2V0dGluZ3MuZW5hYmxlTGl2ZVByZXZpZXcpIHtcclxuICAgICAgdGhpcy5yZWdpc3RlckVkaXRvckV4dGVuc2lvbih0aGlzLmdldEVkaXRvckV4dGVuc2lvbnMoKSk7XHJcbiAgICB9XHJcblxyXG4gICAgdGhpcy5pbmplY3RTdHlsZXMoKTtcclxuICB9XHJcblxyXG4gIG9udW5sb2FkKCkge1xyXG4gICAgY29uc29sZS5sb2coJ1VubG9hZGluZyBDdXN0b20gQ2xhc3MgU3ludGF4IHBsdWdpbicpO1xyXG4gICAgdGhpcy5yZW1vdmVTdHlsZXMoKTtcclxuICB9XHJcblxyXG4gIGFzeW5jIGxvYWRTZXR0aW5ncygpIHtcclxuICAgIHRoaXMuc2V0dGluZ3MgPSBPYmplY3QuYXNzaWduKHt9LCBERUZBVUxUX1NFVFRJTkdTLCBhd2FpdCB0aGlzLmxvYWREYXRhKCkpO1xyXG4gIH1cclxuXHJcbiAgYXN5bmMgc2F2ZVNldHRpbmdzKCkge1xyXG4gICAgYXdhaXQgdGhpcy5zYXZlRGF0YSh0aGlzLnNldHRpbmdzKTtcclxuICB9XHJcblxyXG4gIHByaXZhdGUgZ2V0RWRpdG9yRXh0ZW5zaW9ucygpOiBFeHRlbnNpb25bXSB7XHJcbiAgICByZXR1cm4gW2NyZWF0ZUVkaXRvckV4dGVuc2lvbigpXTtcclxuICB9XHJcblxyXG4gIHByaXZhdGUgaW5qZWN0U3R5bGVzKCkge1xyXG4gICAgdGhpcy5zdHlsZUVsID0gZG9jdW1lbnQuY3JlYXRlRWxlbWVudCgnc3R5bGUnKTtcclxuICAgIHRoaXMuc3R5bGVFbC5pZCA9ICdjdXN0b20tY2xhc3Mtc3ludGF4LXN0eWxlcyc7XHJcbiAgICB0aGlzLnVwZGF0ZVN0eWxlQ29udGVudCgpO1xyXG4gICAgZG9jdW1lbnQuaGVhZC5hcHBlbmRDaGlsZCh0aGlzLnN0eWxlRWwpO1xyXG4gIH1cclxuXHJcbiAgcHJpdmF0ZSB1cGRhdGVTdHlsZUNvbnRlbnQoKSB7XHJcbiAgICBpZiAoIXRoaXMuc3R5bGVFbCkgcmV0dXJuO1xyXG5cclxuICAgIGxldCBjc3MgPSAnJztcclxuXHJcbiAgICBpZiAoIXRoaXMuc2V0dGluZ3Muc2hvd0NsYXNzTGFiZWxzKSB7XHJcbiAgICAgIGNzcyArPSBgLmNjcy1ibG9jazo6YmVmb3JlIHsgZGlzcGxheTogbm9uZSAhaW1wb3J0YW50OyB9YDtcclxuICAgIH1cclxuXHJcbiAgICBpZiAodGhpcy5zZXR0aW5ncy5jdXN0b21DU1MpIHtcclxuICAgICAgY3NzICs9IGBcXG4vKiBVc2VyIEN1c3RvbSBDU1MgKi9cXG4ke3RoaXMuc2V0dGluZ3MuY3VzdG9tQ1NTfWA7XHJcbiAgICB9XHJcblxyXG4gICAgdGhpcy5zdHlsZUVsLnRleHRDb250ZW50ID0gY3NzO1xyXG4gIH1cclxuXHJcbiAgdXBkYXRlU3R5bGVzKCkge1xyXG4gICAgdGhpcy51cGRhdGVTdHlsZUNvbnRlbnQoKTtcclxuICB9XHJcblxyXG4gIHByaXZhdGUgcmVtb3ZlU3R5bGVzKCkge1xyXG4gICAgdGhpcy5zdHlsZUVsPy5yZW1vdmUoKTtcclxuICAgIHRoaXMuc3R5bGVFbCA9IG51bGw7XHJcbiAgfVxyXG59IiwgIi8qKlxyXG4gKiBDb2RlTWlycm9yIDYgRXh0ZW5zaW9uIGZvciBMaXZlIFByZXZpZXdcclxuICogVXBkYXRlZCBmb3IgbmV3IHN5bnRheCBwYXR0ZXJuc1xyXG4gKi9cclxuXHJcbmltcG9ydCB7XHJcbiAgRWRpdG9yVmlldyxcclxuICBEZWNvcmF0aW9uLFxyXG4gIERlY29yYXRpb25TZXQsXHJcbiAgVmlld1BsdWdpbixcclxuICBWaWV3VXBkYXRlLFxyXG59IGZyb20gJ0Bjb2RlbWlycm9yL3ZpZXcnO1xyXG5pbXBvcnQgeyBSYW5nZVNldEJ1aWxkZXIsIEV4dGVuc2lvbiB9IGZyb20gJ0Bjb2RlbWlycm9yL3N0YXRlJztcclxuXHJcbi8vIFBhdHRlcm5zIGZvciBzeW50YXggaGlnaGxpZ2h0aW5nIGluIGVkaXRvclxyXG5jb25zdCBQQVRURVJOUyA9IHtcclxuICAvLyAjIEhlYWRlciA6OjogY2xhc3NcclxuICBIRUFERVI6IC9eKCN7MSw2fSlcXHMrKC4rPylcXHMrKDo6OlxccypbXFx3LV0rKD86XFxzKjpcXHMqW1xcdy1dKykqKVxccyokLyxcclxuICBcclxuICAvLyAtIGl0ZW0gOjo6IGNsYXNzIG9yIC0gWyBdIGl0ZW0gOjo6IGNsYXNzXHJcbiAgTElTVF9JVEVNOiAvXihcXHMqWy0qK10pXFxzKyg/OlxcW1sgeFhdXFxdXFxzKyk/KC4rPylcXHMrKDo6OlxccypbXFx3LV0rKD86XFxzKjpcXHMqW1xcdy1dKykqKVxccyokLyxcclxuICBcclxuICAvLyA+IFshdHlwZV0gVGl0bGUgOjo6IGNsYXNzXHJcbiAgQ0FMTE9VVDogL14+XFxzKlxcWyFcXHcrXFxdKC4qPylcXHMrKDo6OlxccypbXFx3LV0rKD86XFxzKjpcXHMqW1xcdy1dKykqKVxccyokLyxcclxuICBcclxuICAvLyBgYGBsYW5nIDo6OiBjbGFzc1xyXG4gIENPREVfQkxPQ0s6IC9eYGBgKFxcdyopXFxzKiguKj8pXFxzKig6OjpcXHMqW1xcdy1dKyg/Olxccyo6XFxzKltcXHctXSspKilcXHMqJC8sXHJcbiAgXHJcbiAgLy8gOjo6IGNsYXNzIChibG9jayBzdGFydClcclxuICBCTE9DS19TVEFSVDogL146OjpcXHMqKFtcXHctXSsoPzpcXHMqOlxccypbXFx3LV0rKSopXFxzKiQvLFxyXG4gIFxyXG4gIC8vIDo6OiAoYmxvY2sgZW5kKVxyXG4gIEJMT0NLX0VORDogL146OjpcXHMqJC8sXHJcbn07XHJcblxyXG4vLyBEZWNvcmF0aW9uc1xyXG5jb25zdCBtYXJrZXJEZWNvcmF0aW9uID0gRGVjb3JhdGlvbi5tYXJrKHsgY2xhc3M6ICdjY3Mtc3ludGF4LW1hcmtlcicgfSk7XHJcbmNvbnN0IGNsYXNzRGVjb3JhdGlvbiA9IERlY29yYXRpb24ubWFyayh7IGNsYXNzOiAnY2NzLWNsYXNzLW5hbWUnIH0pO1xyXG5jb25zdCBlc2NhcGVkRGVjb3JhdGlvbiA9IERlY29yYXRpb24ubWFyayh7IGNsYXNzOiAnY2NzLWVzY2FwZWQnIH0pO1xyXG5cclxuLyoqXHJcbiAqIENoZWNrIGlmIHBvc2l0aW9uIGlzIGVzY2FwZWRcclxuICovXHJcbmZ1bmN0aW9uIGlzRXNjYXBlZEF0KHRleHQ6IHN0cmluZywgcG9zaXRpb246IG51bWJlcik6IGJvb2xlYW4ge1xyXG4gIGlmIChwb3NpdGlvbiA8PSAwKSByZXR1cm4gZmFsc2U7XHJcbiAgbGV0IGNvdW50ID0gMDtcclxuICBsZXQgaSA9IHBvc2l0aW9uIC0gMTtcclxuICB3aGlsZSAoaSA+PSAwICYmIHRleHRbaV0gPT09ICdcXFxcJykge1xyXG4gICAgY291bnQrKztcclxuICAgIGktLTtcclxuICB9XHJcbiAgcmV0dXJuIGNvdW50ICUgMiA9PT0gMTtcclxufVxyXG5cclxuLyoqXHJcbiAqIEJ1aWxkIGRlY29yYXRpb25zIGZvciB0aGUgZWRpdG9yXHJcbiAqL1xyXG5mdW5jdGlvbiBidWlsZERlY29yYXRpb25zKHZpZXc6IEVkaXRvclZpZXcpOiBEZWNvcmF0aW9uU2V0IHtcclxuICBjb25zdCBidWlsZGVyID0gbmV3IFJhbmdlU2V0QnVpbGRlcjxEZWNvcmF0aW9uPigpO1xyXG4gIGNvbnN0IGRvYyA9IHZpZXcuc3RhdGUuZG9jO1xyXG4gIGNvbnN0IHRleHQgPSBkb2MudG9TdHJpbmcoKTtcclxuICBjb25zdCBsaW5lcyA9IHRleHQuc3BsaXQoJ1xcbicpO1xyXG4gIFxyXG4gIGNvbnN0IGRlY29yYXRpb25zOiBBcnJheTx7IGZyb206IG51bWJlcjsgdG86IG51bWJlcjsgZGVjb3JhdGlvbjogRGVjb3JhdGlvbiB9PiA9IFtdO1xyXG4gIFxyXG4gIGxldCBsaW5lT2Zmc2V0ID0gMDtcclxuICBsZXQgaW5Db2RlQmxvY2sgPSBmYWxzZTtcclxuICBcclxuICBmb3IgKGxldCBpID0gMDsgaSA8IGxpbmVzLmxlbmd0aDsgaSsrKSB7XHJcbiAgICBjb25zdCBsaW5lID0gbGluZXNbaV07XHJcbiAgICBjb25zdCBsaW5lU3RhcnQgPSBsaW5lT2Zmc2V0O1xyXG4gICAgY29uc3QgbGluZUVuZCA9IGxpbmVPZmZzZXQgKyBsaW5lLmxlbmd0aDtcclxuICAgIFxyXG4gICAgLy8gVHJhY2sgY29kZSBibG9ja3NcclxuICAgIGlmIChsaW5lLnRyaW0oKS5zdGFydHNXaXRoKCdgYGAnKSkge1xyXG4gICAgICBpZiAoIWluQ29kZUJsb2NrKSB7XHJcbiAgICAgICAgaW5Db2RlQmxvY2sgPSB0cnVlO1xyXG4gICAgICAgIC8vIENoZWNrIGZvciBjbGFzcyBvbiBjb2RlIGJsb2NrXHJcbiAgICAgICAgY29uc3QgbWF0Y2ggPSBsaW5lLm1hdGNoKFBBVFRFUk5TLkNPREVfQkxPQ0spO1xyXG4gICAgICAgIGlmIChtYXRjaCkge1xyXG4gICAgICAgICAgY29uc3QgbWFya2VyU3RhcnQgPSBsaW5lLmxhc3RJbmRleE9mKCc6OjonKTtcclxuICAgICAgICAgIGlmIChtYXJrZXJTdGFydCAhPT0gLTEgJiYgIWlzRXNjYXBlZEF0KGxpbmUsIG1hcmtlclN0YXJ0KSkge1xyXG4gICAgICAgICAgICBkZWNvcmF0aW9ucy5wdXNoKHtcclxuICAgICAgICAgICAgICBmcm9tOiBsaW5lU3RhcnQgKyBtYXJrZXJTdGFydCxcclxuICAgICAgICAgICAgICB0bzogbGluZVN0YXJ0ICsgbWFya2VyU3RhcnQgKyAzLFxyXG4gICAgICAgICAgICAgIGRlY29yYXRpb246IG1hcmtlckRlY29yYXRpb24sXHJcbiAgICAgICAgICAgIH0pO1xyXG4gICAgICAgICAgICBjb25zdCBjbGFzc1N0YXJ0ID0gbWFya2VyU3RhcnQgKyAzO1xyXG4gICAgICAgICAgICBjb25zdCBjbGFzc0VuZCA9IGxpbmUubGVuZ3RoO1xyXG4gICAgICAgICAgICBpZiAoY2xhc3NFbmQgPiBjbGFzc1N0YXJ0KSB7XHJcbiAgICAgICAgICAgICAgZGVjb3JhdGlvbnMucHVzaCh7XHJcbiAgICAgICAgICAgICAgICBmcm9tOiBsaW5lU3RhcnQgKyBjbGFzc1N0YXJ0LFxyXG4gICAgICAgICAgICAgICAgdG86IGxpbmVTdGFydCArIGNsYXNzRW5kLFxyXG4gICAgICAgICAgICAgICAgZGVjb3JhdGlvbjogY2xhc3NEZWNvcmF0aW9uLFxyXG4gICAgICAgICAgICAgIH0pO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgICB9XHJcbiAgICAgICAgfVxyXG4gICAgICB9IGVsc2Uge1xyXG4gICAgICAgIGluQ29kZUJsb2NrID0gZmFsc2U7XHJcbiAgICAgIH1cclxuICAgICAgbGluZU9mZnNldCA9IGxpbmVFbmQgKyAxO1xyXG4gICAgICBjb250aW51ZTtcclxuICAgIH1cclxuICAgIFxyXG4gICAgLy8gU2tpcCBpbnNpZGUgY29kZSBibG9ja3NcclxuICAgIGlmIChpbkNvZGVCbG9jaykge1xyXG4gICAgICBsaW5lT2Zmc2V0ID0gbGluZUVuZCArIDE7XHJcbiAgICAgIGNvbnRpbnVlO1xyXG4gICAgfVxyXG4gICAgXHJcbiAgICAvLyBDaGVjayBmb3IgZXNjYXBlZCBcXDo6OlxyXG4gICAgY29uc3QgZXNjYXBlZE1hdGNoID0gbGluZS5tYXRjaCgvXFxcXDo6Oi9nKTtcclxuICAgIGlmIChlc2NhcGVkTWF0Y2gpIHtcclxuICAgICAgbGV0IHBvcyA9IDA7XHJcbiAgICAgIHdoaWxlIChwb3MgPCBsaW5lLmxlbmd0aCkge1xyXG4gICAgICAgIGNvbnN0IGlkeCA9IGxpbmUuaW5kZXhPZignXFxcXDo6OicsIHBvcyk7XHJcbiAgICAgICAgaWYgKGlkeCA9PT0gLTEpIGJyZWFrO1xyXG4gICAgICAgIGRlY29yYXRpb25zLnB1c2goe1xyXG4gICAgICAgICAgZnJvbTogbGluZVN0YXJ0ICsgaWR4LFxyXG4gICAgICAgICAgdG86IGxpbmVTdGFydCArIGlkeCArIDQsXHJcbiAgICAgICAgICBkZWNvcmF0aW9uOiBlc2NhcGVkRGVjb3JhdGlvbixcclxuICAgICAgICB9KTtcclxuICAgICAgICBwb3MgPSBpZHggKyA0O1xyXG4gICAgICB9XHJcbiAgICB9XHJcbiAgICBcclxuICAgIC8vIENoZWNrIHZhcmlvdXMgcGF0dGVybnNcclxuICAgIGNvbnN0IHRyaW1tZWQgPSBsaW5lLnRyaW0oKTtcclxuICAgIFxyXG4gICAgLy8gQmxvY2sgc3RhcnQvZW5kXHJcbiAgICBpZiAoUEFUVEVSTlMuQkxPQ0tfU1RBUlQudGVzdCh0cmltbWVkKSkge1xyXG4gICAgICBjb25zdCBtYXJrZXJTdGFydCA9IGxpbmUuaW5kZXhPZignOjo6Jyk7XHJcbiAgICAgIGlmIChtYXJrZXJTdGFydCAhPT0gLTEgJiYgIWlzRXNjYXBlZEF0KGxpbmUsIG1hcmtlclN0YXJ0KSkge1xyXG4gICAgICAgIGRlY29yYXRpb25zLnB1c2goe1xyXG4gICAgICAgICAgZnJvbTogbGluZVN0YXJ0ICsgbWFya2VyU3RhcnQsXHJcbiAgICAgICAgICB0bzogbGluZVN0YXJ0ICsgbWFya2VyU3RhcnQgKyAzLFxyXG4gICAgICAgICAgZGVjb3JhdGlvbjogbWFya2VyRGVjb3JhdGlvbixcclxuICAgICAgICB9KTtcclxuICAgICAgICBjb25zdCBhZnRlck1hcmtlciA9IG1hcmtlclN0YXJ0ICsgMztcclxuICAgICAgICBjb25zdCBjbGFzc0VuZCA9IGxpbmUudHJpbUVuZCgpLmxlbmd0aDtcclxuICAgICAgICBpZiAoY2xhc3NFbmQgPiBhZnRlck1hcmtlcikge1xyXG4gICAgICAgICAgZGVjb3JhdGlvbnMucHVzaCh7XHJcbiAgICAgICAgICAgIGZyb206IGxpbmVTdGFydCArIGFmdGVyTWFya2VyLFxyXG4gICAgICAgICAgICB0bzogbGluZVN0YXJ0ICsgY2xhc3NFbmQsXHJcbiAgICAgICAgICAgIGRlY29yYXRpb246IGNsYXNzRGVjb3JhdGlvbixcclxuICAgICAgICAgIH0pO1xyXG4gICAgICAgIH1cclxuICAgICAgfVxyXG4gICAgfSBlbHNlIGlmIChQQVRURVJOUy5CTE9DS19FTkQudGVzdCh0cmltbWVkKSkge1xyXG4gICAgICBjb25zdCBtYXJrZXJTdGFydCA9IGxpbmUuaW5kZXhPZignOjo6Jyk7XHJcbiAgICAgIGlmIChtYXJrZXJTdGFydCAhPT0gLTEgJiYgIWlzRXNjYXBlZEF0KGxpbmUsIG1hcmtlclN0YXJ0KSkge1xyXG4gICAgICAgIGRlY29yYXRpb25zLnB1c2goe1xyXG4gICAgICAgICAgZnJvbTogbGluZVN0YXJ0ICsgbWFya2VyU3RhcnQsXHJcbiAgICAgICAgICB0bzogbGluZVN0YXJ0ICsgbWFya2VyU3RhcnQgKyAzLFxyXG4gICAgICAgICAgZGVjb3JhdGlvbjogbWFya2VyRGVjb3JhdGlvbixcclxuICAgICAgICB9KTtcclxuICAgICAgfVxyXG4gICAgfVxyXG4gICAgXHJcbiAgICAvLyBIZWFkZXIsIGxpc3QgaXRlbSwgY2FsbG91dFxyXG4gICAgZm9yIChjb25zdCBwYXR0ZXJuIG9mIFtQQVRURVJOUy5IRUFERVIsIFBBVFRFUk5TLkxJU1RfSVRFTSwgUEFUVEVSTlMuQ0FMTE9VVF0pIHtcclxuICAgICAgY29uc3QgbWF0Y2ggPSBsaW5lLm1hdGNoKHBhdHRlcm4pO1xyXG4gICAgICBpZiAobWF0Y2gpIHtcclxuICAgICAgICAvLyBGaW5kIDo6OiBwb3NpdGlvblxyXG4gICAgICAgIGNvbnN0IG1hcmtlclN0YXJ0ID0gbGluZS5sYXN0SW5kZXhPZignOjo6Jyk7XHJcbiAgICAgICAgaWYgKG1hcmtlclN0YXJ0ICE9PSAtMSAmJiAhaXNFc2NhcGVkQXQobGluZSwgbWFya2VyU3RhcnQpKSB7XHJcbiAgICAgICAgICBkZWNvcmF0aW9ucy5wdXNoKHtcclxuICAgICAgICAgICAgZnJvbTogbGluZVN0YXJ0ICsgbWFya2VyU3RhcnQsXHJcbiAgICAgICAgICAgIHRvOiBsaW5lU3RhcnQgKyBtYXJrZXJTdGFydCArIDMsXHJcbiAgICAgICAgICAgIGRlY29yYXRpb246IG1hcmtlckRlY29yYXRpb24sXHJcbiAgICAgICAgICB9KTtcclxuICAgICAgICAgIGNvbnN0IGNsYXNzU3RhcnQgPSBtYXJrZXJTdGFydCArIDM7XHJcbiAgICAgICAgICBjb25zdCBjbGFzc0VuZCA9IGxpbmUudHJpbUVuZCgpLmxlbmd0aDtcclxuICAgICAgICAgIGlmIChjbGFzc0VuZCA+IGNsYXNzU3RhcnQpIHtcclxuICAgICAgICAgICAgZGVjb3JhdGlvbnMucHVzaCh7XHJcbiAgICAgICAgICAgICAgZnJvbTogbGluZVN0YXJ0ICsgY2xhc3NTdGFydCxcclxuICAgICAgICAgICAgICB0bzogbGluZVN0YXJ0ICsgY2xhc3NFbmQsXHJcbiAgICAgICAgICAgICAgZGVjb3JhdGlvbjogY2xhc3NEZWNvcmF0aW9uLFxyXG4gICAgICAgICAgICB9KTtcclxuICAgICAgICAgIH1cclxuICAgICAgICB9XHJcbiAgICAgICAgYnJlYWs7XHJcbiAgICAgIH1cclxuICAgIH1cclxuICAgIFxyXG4gICAgLy8gSW5saW5lOiBgY29kZWAgOjo6IGNsYXNzIGFuZCA6OjogY2xhc3MgOiBjb250ZW50IDo6OlxyXG4gICAgLy8gSW5saW5lIGNvZGVcclxuICAgIGNvbnN0IGlubGluZUNvZGVSZWdleCA9IC9gW15gXStgXFxzKjo6OlxccypbXFx3LV0rKD86XFxzKjpcXHMqW1xcdy1dKykqL2c7XHJcbiAgICBsZXQgaW5saW5lTWF0Y2g6IFJlZ0V4cEV4ZWNBcnJheSB8IG51bGw7XHJcbiAgICB3aGlsZSAoKGlubGluZU1hdGNoID0gaW5saW5lQ29kZVJlZ2V4LmV4ZWMobGluZSkpICE9PSBudWxsKSB7XHJcbiAgICAgIGNvbnN0IG1hcmtlclBvcyA9IGlubGluZU1hdGNoWzBdLmluZGV4T2YoJzo6OicpO1xyXG4gICAgICBjb25zdCBnbG9iYWxQb3MgPSBpbmxpbmVNYXRjaC5pbmRleCArIG1hcmtlclBvcztcclxuICAgICAgaWYgKCFpc0VzY2FwZWRBdChsaW5lLCBnbG9iYWxQb3MpKSB7XHJcbiAgICAgICAgZGVjb3JhdGlvbnMucHVzaCh7XHJcbiAgICAgICAgICBmcm9tOiBsaW5lU3RhcnQgKyBnbG9iYWxQb3MsXHJcbiAgICAgICAgICB0bzogbGluZVN0YXJ0ICsgaW5saW5lTWF0Y2guaW5kZXggKyBpbmxpbmVNYXRjaFswXS5sZW5ndGgsXHJcbiAgICAgICAgICBkZWNvcmF0aW9uOiBtYXJrZXJEZWNvcmF0aW9uLFxyXG4gICAgICAgIH0pO1xyXG4gICAgICB9XHJcbiAgICB9XHJcbiAgICBcclxuICAgIC8vIElubGluZSB0ZXh0IDo6OiBjbGFzcyA6IGNvbnRlbnQgOjo6XHJcbiAgICBjb25zdCBpbmxpbmVUZXh0UmVnZXggPSAvOjo6KC4rPyk6OjovZztcclxuICAgIHdoaWxlICgoaW5saW5lTWF0Y2ggPSBpbmxpbmVUZXh0UmVnZXguZXhlYyhsaW5lKSkgIT09IG51bGwpIHtcclxuICAgICAgaWYgKGlzRXNjYXBlZEF0KGxpbmUsIGlubGluZU1hdGNoLmluZGV4KSkgY29udGludWU7XHJcbiAgICAgIFxyXG4gICAgICAvLyBPcGVuaW5nIDo6OlxyXG4gICAgICBkZWNvcmF0aW9ucy5wdXNoKHtcclxuICAgICAgICBmcm9tOiBsaW5lU3RhcnQgKyBpbmxpbmVNYXRjaC5pbmRleCxcclxuICAgICAgICB0bzogbGluZVN0YXJ0ICsgaW5saW5lTWF0Y2guaW5kZXggKyAzLFxyXG4gICAgICAgIGRlY29yYXRpb246IG1hcmtlckRlY29yYXRpb24sXHJcbiAgICAgIH0pO1xyXG4gICAgICBcclxuICAgICAgLy8gQ29udGVudCAoZmluZCBsYXN0IDogdG8gc2VwYXJhdGUgY2xhc3MgZnJvbSBjb250ZW50KVxyXG4gICAgICBjb25zdCBpbm5lciA9IGlubGluZU1hdGNoWzFdO1xyXG4gICAgICBjb25zdCBsYXN0Q29sb24gPSBpbm5lci5sYXN0SW5kZXhPZignOicpO1xyXG4gICAgICBpZiAobGFzdENvbG9uID4gMCkge1xyXG4gICAgICAgIGNvbnN0IGNsYXNzRW5kID0gaW5saW5lTWF0Y2guaW5kZXggKyAzICsgbGFzdENvbG9uO1xyXG4gICAgICAgIGRlY29yYXRpb25zLnB1c2goe1xyXG4gICAgICAgICAgZnJvbTogbGluZVN0YXJ0ICsgaW5saW5lTWF0Y2guaW5kZXggKyAzLFxyXG4gICAgICAgICAgdG86IGxpbmVTdGFydCArIGNsYXNzRW5kLFxyXG4gICAgICAgICAgZGVjb3JhdGlvbjogY2xhc3NEZWNvcmF0aW9uLFxyXG4gICAgICAgIH0pO1xyXG4gICAgICB9XHJcbiAgICAgIFxyXG4gICAgICAvLyBDbG9zaW5nIDo6OlxyXG4gICAgICBkZWNvcmF0aW9ucy5wdXNoKHtcclxuICAgICAgICBmcm9tOiBsaW5lU3RhcnQgKyBpbmxpbmVNYXRjaC5pbmRleCArIGlubGluZU1hdGNoWzBdLmxlbmd0aCAtIDMsXHJcbiAgICAgICAgdG86IGxpbmVTdGFydCArIGlubGluZU1hdGNoLmluZGV4ICsgaW5saW5lTWF0Y2hbMF0ubGVuZ3RoLFxyXG4gICAgICAgIGRlY29yYXRpb246IG1hcmtlckRlY29yYXRpb24sXHJcbiAgICAgIH0pO1xyXG4gICAgfVxyXG4gICAgXHJcbiAgICBsaW5lT2Zmc2V0ID0gbGluZUVuZCArIDE7XHJcbiAgfVxyXG4gIFxyXG4gIC8vIFNvcnQgYW5kIGZpbHRlciBvdmVybGFwcGluZ1xyXG4gIGRlY29yYXRpb25zLnNvcnQoKGEsIGIpID0+IGEuZnJvbSAtIGIuZnJvbSB8fCBhLnRvIC0gYi50byk7XHJcbiAgXHJcbiAgbGV0IGxhc3RFbmQgPSAtMTtcclxuICBmb3IgKGNvbnN0IGRlYyBvZiBkZWNvcmF0aW9ucykge1xyXG4gICAgaWYgKGRlYy5mcm9tID49IGxhc3RFbmQgJiYgZGVjLmZyb20gPj0gMCAmJiBkZWMudG8gPiBkZWMuZnJvbSAmJiBkZWMudG8gPD0gdGV4dC5sZW5ndGgpIHtcclxuICAgICAgYnVpbGRlci5hZGQoZGVjLmZyb20sIGRlYy50bywgZGVjLmRlY29yYXRpb24pO1xyXG4gICAgICBsYXN0RW5kID0gZGVjLnRvO1xyXG4gICAgfVxyXG4gIH1cclxuICBcclxuICByZXR1cm4gYnVpbGRlci5maW5pc2goKTtcclxufVxyXG5cclxuLyoqXHJcbiAqIFZpZXcgcGx1Z2luXHJcbiAqL1xyXG5jb25zdCBkZWNvcmF0aW9uUGx1Z2luID0gVmlld1BsdWdpbi5mcm9tQ2xhc3MoXHJcbiAgY2xhc3Mge1xyXG4gICAgZGVjb3JhdGlvbnM6IERlY29yYXRpb25TZXQ7XHJcblxyXG4gICAgY29uc3RydWN0b3IodmlldzogRWRpdG9yVmlldykge1xyXG4gICAgICB0aGlzLmRlY29yYXRpb25zID0gYnVpbGREZWNvcmF0aW9ucyh2aWV3KTtcclxuICAgIH1cclxuXHJcbiAgICB1cGRhdGUodXBkYXRlOiBWaWV3VXBkYXRlKSB7XHJcbiAgICAgIGlmICh1cGRhdGUuZG9jQ2hhbmdlZCB8fCB1cGRhdGUudmlld3BvcnRDaGFuZ2VkKSB7XHJcbiAgICAgICAgdGhpcy5kZWNvcmF0aW9ucyA9IGJ1aWxkRGVjb3JhdGlvbnModXBkYXRlLnZpZXcpO1xyXG4gICAgICB9XHJcbiAgICB9XHJcbiAgfSxcclxuICB7XHJcbiAgICBkZWNvcmF0aW9uczogKHYpID0+IHYuZGVjb3JhdGlvbnMsXHJcbiAgfVxyXG4pO1xyXG5cclxuLyoqXHJcbiAqIFRoZW1lXHJcbiAqL1xyXG5jb25zdCBkZWNvcmF0aW9uVGhlbWUgPSBFZGl0b3JWaWV3LmJhc2VUaGVtZSh7XHJcbiAgJy5jY3Mtc3ludGF4LW1hcmtlcic6IHtcclxuICAgIGNvbG9yOiAndmFyKC0tdGV4dC1mYWludCknLFxyXG4gICAgZm9udEZhbWlseTogJ3ZhcigtLWZvbnQtbW9ub3NwYWNlKScsXHJcbiAgICBmb250U2l6ZTogJzAuOWVtJyxcclxuICB9LFxyXG4gICcuY2NzLWNsYXNzLW5hbWUnOiB7XHJcbiAgICBjb2xvcjogJ3ZhcigtLWNvbG9yLWN5YW4pJyxcclxuICAgIGZvbnRGYW1pbHk6ICd2YXIoLS1mb250LW1vbm9zcGFjZSknLFxyXG4gICAgYmFja2dyb3VuZENvbG9yOiAndmFyKC0tYmFja2dyb3VuZC1tb2RpZmllci1jb2RlKScsXHJcbiAgICBib3JkZXJSYWRpdXM6ICczcHgnLFxyXG4gICAgcGFkZGluZzogJzAgM3B4JyxcclxuICB9LFxyXG4gICcuY2NzLWVzY2FwZWQnOiB7XHJcbiAgICBjb2xvcjogJ3ZhcigtLXRleHQtbXV0ZWQpJyxcclxuICAgIG9wYWNpdHk6ICcwLjYnLFxyXG4gIH0sXHJcbn0pO1xyXG5cclxuLyoqXHJcbiAqIEV4cG9ydCBleHRlbnNpb25cclxuICovXHJcbmV4cG9ydCBmdW5jdGlvbiBjcmVhdGVFZGl0b3JFeHRlbnNpb24oKTogRXh0ZW5zaW9uIHtcclxuICByZXR1cm4gW2RlY29yYXRpb25QbHVnaW4sIGRlY29yYXRpb25UaGVtZV07XHJcbn0iLCAiLyoqXHJcbiAqIFBhcnNlciBmb3IgY3VzdG9tIGNsYXNzIHN5bnRheFxyXG4gKi9cclxuXHJcbmV4cG9ydCBpbnRlcmZhY2UgQ2xhc3NJbmZvIHtcclxuICB0eXBlOiBcclxuICAgIHwgJ2hlYWRlcicgXHJcbiAgICB8ICdsaXN0LWl0ZW0nIFxyXG4gICAgfCAnY2FsbG91dCcgXHJcbiAgICB8ICdjb2RlLWJsb2NrJyBcclxuICAgIHwgJ2NoZWNrYm94JyBcclxuICAgIHwgJ2Jsb2NrLXN0YXJ0JyBcclxuICAgIHwgJ2Jsb2NrLWVuZCcgXHJcbiAgICB8ICdibG9jay1jb250ZW50JztcclxuICBjbGFzc2VzOiBzdHJpbmdbXTtcclxuICBjb250ZW50V2l0aG91dE1hcmtlcj86IHN0cmluZztcclxufVxyXG5cclxuZXhwb3J0IGludGVyZmFjZSBCbG9ja0luZm8ge1xyXG4gIHN0YXJ0TGluZTogbnVtYmVyO1xyXG4gIGVuZExpbmU6IG51bWJlcjtcclxuICBjbGFzc2VzOiBzdHJpbmdbXTtcclxuICB0eXBlOiAndGFibGUnIHwgJ2xpc3QnIHwgJ2dlbmVyYWwnO1xyXG59XHJcblxyXG5leHBvcnQgaW50ZXJmYWNlIElubGluZVRleHRNYXRjaCB7XHJcbiAgc3RhcnQ6IG51bWJlcjtcclxuICBlbmQ6IG51bWJlcjtcclxuICBjbGFzc2VzOiBzdHJpbmdbXTtcclxuICBjb250ZW50OiBzdHJpbmc7XHJcbn1cclxuXHJcbmV4cG9ydCBpbnRlcmZhY2UgU291cmNlUGFyc2VSZXN1bHQge1xyXG4gIGxpbmVJbmZvOiBNYXA8bnVtYmVyLCBDbGFzc0luZm8+O1xyXG4gIGJsb2NrczogQmxvY2tJbmZvW107XHJcbiAgY29kZUJsb2NrTGluZXM6IFNldDxudW1iZXI+O1xyXG59XHJcblxyXG4vKipcclxuICogUGFyc2UgY2xhc3NlcyBmcm9tIHN0cmluZyBsaWtlIFwiY2xhc3MxIDogY2xhc3MyXCJcclxuICovXHJcbmV4cG9ydCBmdW5jdGlvbiBwYXJzZUNsYXNzZXMoY2xhc3NTdHJpbmc6IHN0cmluZyk6IHN0cmluZ1tdIHtcclxuICBpZiAoIWNsYXNzU3RyaW5nKSByZXR1cm4gW107XHJcbiAgcmV0dXJuIGNsYXNzU3RyaW5nXHJcbiAgICAuc3BsaXQoJzonKVxyXG4gICAgLm1hcChjID0+IGMudHJpbSgpLnJlcGxhY2UoL15cXC4vLCAnJykpXHJcbiAgICAuZmlsdGVyKGMgPT4gYy5sZW5ndGggPiAwICYmIGlzVmFsaWRDbGFzc05hbWUoYykpO1xyXG59XHJcblxyXG4vKipcclxuICogVmFsaWRhdGUgQ1NTIGNsYXNzIG5hbWVcclxuICovXHJcbmV4cG9ydCBmdW5jdGlvbiBpc1ZhbGlkQ2xhc3NOYW1lKG5hbWU6IHN0cmluZyk6IGJvb2xlYW4ge1xyXG4gIHJldHVybiAvXlthLXpBLVpfLV1bYS16QS1aMC05Xy1dKiQvLnRlc3QobmFtZSk7XHJcbn1cclxuXHJcbi8qKlxyXG4gKiBDaGVjayBpZiBwb3NpdGlvbiBpcyBlc2NhcGVkXHJcbiAqL1xyXG5leHBvcnQgZnVuY3Rpb24gaXNFc2NhcGVkQXQodGV4dDogc3RyaW5nLCBwb3NpdGlvbjogbnVtYmVyKTogYm9vbGVhbiB7XHJcbiAgaWYgKHBvc2l0aW9uIDw9IDApIHJldHVybiBmYWxzZTtcclxuICBsZXQgYmFja3NsYXNoQ291bnQgPSAwO1xyXG4gIGxldCBpID0gcG9zaXRpb24gLSAxO1xyXG4gIHdoaWxlIChpID49IDAgJiYgdGV4dFtpXSA9PT0gJ1xcXFwnKSB7XHJcbiAgICBiYWNrc2xhc2hDb3VudCsrO1xyXG4gICAgaS0tO1xyXG4gIH1cclxuICByZXR1cm4gYmFja3NsYXNoQ291bnQgJSAyID09PSAxO1xyXG59XHJcblxyXG4vKipcclxuICogRmluZCB1bmVzY2FwZWQgOjo6IGluIHRleHRcclxuICovXHJcbmZ1bmN0aW9uIGZpbmRVbmVzY2FwZWRNYXJrZXIodGV4dDogc3RyaW5nLCBzdGFydEZyb206IG51bWJlciA9IDApOiBudW1iZXIge1xyXG4gIGxldCBwb3MgPSBzdGFydEZyb207XHJcbiAgd2hpbGUgKHBvcyA8IHRleHQubGVuZ3RoKSB7XHJcbiAgICBjb25zdCBpZHggPSB0ZXh0LmluZGV4T2YoJzo6OicsIHBvcyk7XHJcbiAgICBpZiAoaWR4ID09PSAtMSkgcmV0dXJuIC0xO1xyXG4gICAgaWYgKCFpc0VzY2FwZWRBdCh0ZXh0LCBpZHgpKSB7XHJcbiAgICAgIHJldHVybiBpZHg7XHJcbiAgICB9XHJcbiAgICBwb3MgPSBpZHggKyAzO1xyXG4gIH1cclxuICByZXR1cm4gLTE7XHJcbn1cclxuXHJcbi8qKlxyXG4gKiBQYXJzZSB0aGUgZW50aXJlIHNvdXJjZSB0ZXh0XHJcbiAqL1xyXG5leHBvcnQgZnVuY3Rpb24gcGFyc2VTb3VyY2UodGV4dDogc3RyaW5nKTogU291cmNlUGFyc2VSZXN1bHQge1xyXG4gIGNvbnN0IGxpbmVzID0gdGV4dC5zcGxpdCgnXFxuJyk7XHJcbiAgY29uc3QgbGluZUluZm8gPSBuZXcgTWFwPG51bWJlciwgQ2xhc3NJbmZvPigpO1xyXG4gIGNvbnN0IGJsb2NrczogQmxvY2tJbmZvW10gPSBbXTtcclxuICBjb25zdCBjb2RlQmxvY2tMaW5lcyA9IG5ldyBTZXQ8bnVtYmVyPigpO1xyXG4gIFxyXG4gIGxldCBpbkNvZGVCbG9jayA9IGZhbHNlO1xyXG4gIGxldCBjb2RlQmxvY2tTdGFydExpbmUgPSAtMTtcclxuICBsZXQgY3VycmVudEJsb2NrOiB7IHN0YXJ0TGluZTogbnVtYmVyOyBjbGFzc2VzOiBzdHJpbmdbXTsgdHlwZTogJ3RhYmxlJyB8ICdsaXN0JyB8ICdnZW5lcmFsJyB9IHwgbnVsbCA9IG51bGw7XHJcbiAgXHJcbiAgZm9yIChsZXQgaSA9IDA7IGkgPCBsaW5lcy5sZW5ndGg7IGkrKykge1xyXG4gICAgY29uc3QgbGluZSA9IGxpbmVzW2ldO1xyXG4gICAgY29uc3QgdHJpbW1lZExpbmUgPSBsaW5lLnRyaW0oKTtcclxuICAgIFxyXG4gICAgLy8gSGFuZGxlIGNvZGUgYmxvY2tzXHJcbiAgICBpZiAodHJpbW1lZExpbmUuc3RhcnRzV2l0aCgnYGBgJykpIHtcclxuICAgICAgaWYgKCFpbkNvZGVCbG9jaykge1xyXG4gICAgICAgIGluQ29kZUJsb2NrID0gdHJ1ZTtcclxuICAgICAgICBjb2RlQmxvY2tTdGFydExpbmUgPSBpO1xyXG4gICAgICAgIFxyXG4gICAgICAgIC8vIENoZWNrIGZvciBjbGFzczogYGBgbGFuZyA6OjogY2xhc3NcclxuICAgICAgICBjb25zdCBtYXJrZXJQb3MgPSBmaW5kVW5lc2NhcGVkTWFya2VyKHRyaW1tZWRMaW5lKTtcclxuICAgICAgICBpZiAobWFya2VyUG9zICE9PSAtMSkge1xyXG4gICAgICAgICAgY29uc3QgYWZ0ZXJNYXJrZXIgPSB0cmltbWVkTGluZS5zbGljZShtYXJrZXJQb3MgKyAzKS50cmltKCk7XHJcbiAgICAgICAgICBjb25zdCBjbGFzc2VzID0gcGFyc2VDbGFzc2VzKGFmdGVyTWFya2VyKTtcclxuICAgICAgICAgIGlmIChjbGFzc2VzLmxlbmd0aCA+IDApIHtcclxuICAgICAgICAgICAgbGluZUluZm8uc2V0KGksIHsgdHlwZTogJ2NvZGUtYmxvY2snLCBjbGFzc2VzIH0pO1xyXG4gICAgICAgICAgfVxyXG4gICAgICAgIH1cclxuICAgICAgfSBlbHNlIHtcclxuICAgICAgICBpbkNvZGVCbG9jayA9IGZhbHNlO1xyXG4gICAgICAgIGZvciAobGV0IGogPSBjb2RlQmxvY2tTdGFydExpbmU7IGogPD0gaTsgaisrKSB7XHJcbiAgICAgICAgICBjb2RlQmxvY2tMaW5lcy5hZGQoaik7XHJcbiAgICAgICAgfVxyXG4gICAgICB9XHJcbiAgICAgIGNvbnRpbnVlO1xyXG4gICAgfVxyXG4gICAgXHJcbiAgICBpZiAoaW5Db2RlQmxvY2spIGNvbnRpbnVlO1xyXG4gICAgXHJcbiAgICAvLyBCbG9jayBlbmQ6IDo6OlxyXG4gICAgaWYgKC9eOjo6XFxzKiQvLnRlc3QodHJpbW1lZExpbmUpICYmIGN1cnJlbnRCbG9jaykge1xyXG4gICAgICBibG9ja3MucHVzaCh7XHJcbiAgICAgICAgc3RhcnRMaW5lOiBjdXJyZW50QmxvY2suc3RhcnRMaW5lLFxyXG4gICAgICAgIGVuZExpbmU6IGksXHJcbiAgICAgICAgY2xhc3NlczogY3VycmVudEJsb2NrLmNsYXNzZXMsXHJcbiAgICAgICAgdHlwZTogY3VycmVudEJsb2NrLnR5cGUsXHJcbiAgICAgIH0pO1xyXG4gICAgICBsaW5lSW5mby5zZXQoaSwgeyB0eXBlOiAnYmxvY2stZW5kJywgY2xhc3NlczogY3VycmVudEJsb2NrLmNsYXNzZXMgfSk7XHJcbiAgICAgIGN1cnJlbnRCbG9jayA9IG51bGw7XHJcbiAgICAgIGNvbnRpbnVlO1xyXG4gICAgfVxyXG4gICAgXHJcbiAgICAvLyBCbG9jayBzdGFydDogOjo6IGNsYXNzXHJcbiAgICBjb25zdCBibG9ja1N0YXJ0TWF0Y2ggPSB0cmltbWVkTGluZS5tYXRjaCgvXjo6OlxccyooW1xcdy1dKyg/Olxccyo6XFxzKltcXHctXSspKilcXHMqJC8pO1xyXG4gICAgaWYgKGJsb2NrU3RhcnRNYXRjaCAmJiAhY3VycmVudEJsb2NrKSB7XHJcbiAgICAgIGNvbnN0IGNsYXNzZXMgPSBwYXJzZUNsYXNzZXMoYmxvY2tTdGFydE1hdGNoWzFdKTtcclxuICAgICAgaWYgKGNsYXNzZXMubGVuZ3RoID4gMCkge1xyXG4gICAgICAgIGxldCBibG9ja1R5cGU6ICd0YWJsZScgfCAnbGlzdCcgfCAnZ2VuZXJhbCcgPSAnZ2VuZXJhbCc7XHJcbiAgICAgICAgZm9yIChsZXQgaiA9IGkgKyAxOyBqIDwgbGluZXMubGVuZ3RoOyBqKyspIHtcclxuICAgICAgICAgIGNvbnN0IG5leHRMaW5lID0gbGluZXNbal0udHJpbSgpO1xyXG4gICAgICAgICAgaWYgKCFuZXh0TGluZSkgY29udGludWU7XHJcbiAgICAgICAgICBpZiAobmV4dExpbmUuc3RhcnRzV2l0aCgnfCcpKSB7IGJsb2NrVHlwZSA9ICd0YWJsZSc7IGJyZWFrOyB9XHJcbiAgICAgICAgICBpZiAoL15bLSorXVxccy8udGVzdChuZXh0TGluZSkgfHwgL15cXGQrXFwuXFxzLy50ZXN0KG5leHRMaW5lKSkgeyBibG9ja1R5cGUgPSAnbGlzdCc7IGJyZWFrOyB9XHJcbiAgICAgICAgICBpZiAobmV4dExpbmUuc3RhcnRzV2l0aCgnOjo6JykpIGJyZWFrO1xyXG4gICAgICAgICAgYnJlYWs7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIGN1cnJlbnRCbG9jayA9IHsgc3RhcnRMaW5lOiBpLCBjbGFzc2VzLCB0eXBlOiBibG9ja1R5cGUgfTtcclxuICAgICAgICBsaW5lSW5mby5zZXQoaSwgeyB0eXBlOiAnYmxvY2stc3RhcnQnLCBjbGFzc2VzIH0pO1xyXG4gICAgICB9XHJcbiAgICAgIGNvbnRpbnVlO1xyXG4gICAgfVxyXG4gICAgXHJcbiAgICAvLyBNYXJrIGxpbmVzIGluc2lkZSBhIGJsb2NrXHJcbiAgICBpZiAoY3VycmVudEJsb2NrKSB7XHJcbiAgICAgIGxpbmVJbmZvLnNldChpLCB7IHR5cGU6ICdibG9jay1jb250ZW50JywgY2xhc3NlczogY3VycmVudEJsb2NrLmNsYXNzZXMgfSk7XHJcbiAgICAgIGNvbnRpbnVlO1xyXG4gICAgfVxyXG4gICAgXHJcbiAgICAvLyBIZWFkZXI6ICMgSGVhZGVyIHRleHQgOjo6IGNsYXNzXHJcbiAgICBjb25zdCBoZWFkZXJNYXRjaCA9IHRyaW1tZWRMaW5lLm1hdGNoKC9eKCN7MSw2fSlcXHMrKC4rPylcXHMrOjo6XFxzKihbXFx3LV0rKD86XFxzKjpcXHMqW1xcdy1dKykqKVxccyokLyk7XHJcbiAgICBpZiAoaGVhZGVyTWF0Y2ggJiYgZmluZFVuZXNjYXBlZE1hcmtlcih0cmltbWVkTGluZSkgIT09IC0xKSB7XHJcbiAgICAgIGNvbnN0IGNsYXNzZXMgPSBwYXJzZUNsYXNzZXMoaGVhZGVyTWF0Y2hbM10pO1xyXG4gICAgICBpZiAoY2xhc3Nlcy5sZW5ndGggPiAwKSB7XHJcbiAgICAgICAgbGluZUluZm8uc2V0KGksIHsgdHlwZTogJ2hlYWRlcicsIGNsYXNzZXMsIGNvbnRlbnRXaXRob3V0TWFya2VyOiBoZWFkZXJNYXRjaFsyXS50cmltKCkgfSk7XHJcbiAgICAgIH1cclxuICAgICAgY29udGludWU7XHJcbiAgICB9XHJcbiAgICBcclxuICAgIC8vIENhbGxvdXQ6ID4gWyF0eXBlXSBUaXRsZSA6OjogY2xhc3NcclxuICAgIGNvbnN0IGNhbGxvdXRNYXRjaCA9IHRyaW1tZWRMaW5lLm1hdGNoKC9ePlxccypcXFshKFxcdyspXFxdKC4qPylcXHMqOjo6XFxzKihbXFx3LV0rKD86XFxzKjpcXHMqW1xcdy1dKykqKVxccyokLyk7XHJcbiAgICBpZiAoY2FsbG91dE1hdGNoICYmIGZpbmRVbmVzY2FwZWRNYXJrZXIodHJpbW1lZExpbmUpICE9PSAtMSkge1xyXG4gICAgICBjb25zdCBjbGFzc2VzID0gcGFyc2VDbGFzc2VzKGNhbGxvdXRNYXRjaFszXSk7XHJcbiAgICAgIGlmIChjbGFzc2VzLmxlbmd0aCA+IDApIHtcclxuICAgICAgICBsaW5lSW5mby5zZXQoaSwgeyB0eXBlOiAnY2FsbG91dCcsIGNsYXNzZXMsIGNvbnRlbnRXaXRob3V0TWFya2VyOiBjYWxsb3V0TWF0Y2hbMl0udHJpbSgpIH0pO1xyXG4gICAgICB9XHJcbiAgICAgIGNvbnRpbnVlO1xyXG4gICAgfVxyXG4gIH1cclxuICBcclxuICByZXR1cm4geyBsaW5lSW5mbywgYmxvY2tzLCBjb2RlQmxvY2tMaW5lcyB9O1xyXG59XHJcblxyXG4vKipcclxuICogUGFyc2UgaW5saW5lIHRleHQgc3ludGF4OiA6OjogY2xhc3MgOiBjb250ZW50IDo6OlxyXG4gKi9cclxuZXhwb3J0IGZ1bmN0aW9uIHBhcnNlSW5saW5lVGV4dCh0ZXh0OiBzdHJpbmcpOiBJbmxpbmVUZXh0TWF0Y2hbXSB7XHJcbiAgY29uc3QgbWF0Y2hlczogSW5saW5lVGV4dE1hdGNoW10gPSBbXTtcclxuICBjb25zdCByZWdleCA9IC86OjooLis/KTo6Oi9nO1xyXG4gIGxldCBtYXRjaDogUmVnRXhwRXhlY0FycmF5IHwgbnVsbDtcclxuICBcclxuICB3aGlsZSAoKG1hdGNoID0gcmVnZXguZXhlYyh0ZXh0KSkgIT09IG51bGwpIHtcclxuICAgIGlmIChpc0VzY2FwZWRBdCh0ZXh0LCBtYXRjaC5pbmRleCkpIGNvbnRpbnVlO1xyXG4gICAgXHJcbiAgICBjb25zdCBjbG9zZVBvcyA9IG1hdGNoLmluZGV4ICsgbWF0Y2hbMF0ubGVuZ3RoIC0gMztcclxuICAgIGlmIChpc0VzY2FwZWRBdCh0ZXh0LCBjbG9zZVBvcykpIGNvbnRpbnVlO1xyXG4gICAgXHJcbiAgICBjb25zdCBpbm5lciA9IG1hdGNoWzFdLnRyaW0oKTtcclxuICAgIGNvbnN0IGxhc3RDb2xvbkluZGV4ID0gaW5uZXIubGFzdEluZGV4T2YoJzonKTtcclxuICAgIGlmIChsYXN0Q29sb25JbmRleCA9PT0gLTEpIGNvbnRpbnVlO1xyXG4gICAgXHJcbiAgICBjb25zdCBjbGFzc2VzU3RyID0gaW5uZXIuc2xpY2UoMCwgbGFzdENvbG9uSW5kZXgpLnRyaW0oKTtcclxuICAgIGNvbnN0IGNvbnRlbnQgPSBpbm5lci5zbGljZShsYXN0Q29sb25JbmRleCArIDEpLnRyaW0oKTtcclxuICAgIFxyXG4gICAgaWYgKCFjb250ZW50IHx8ICFjbGFzc2VzU3RyKSBjb250aW51ZTtcclxuICAgIFxyXG4gICAgY29uc3QgY2xhc3NlcyA9IHBhcnNlQ2xhc3NlcyhjbGFzc2VzU3RyKTtcclxuICAgIGlmIChjbGFzc2VzLmxlbmd0aCA+IDApIHtcclxuICAgICAgbWF0Y2hlcy5wdXNoKHsgc3RhcnQ6IG1hdGNoLmluZGV4LCBlbmQ6IG1hdGNoLmluZGV4ICsgbWF0Y2hbMF0ubGVuZ3RoLCBjbGFzc2VzLCBjb250ZW50IH0pO1xyXG4gICAgfVxyXG4gIH1cclxuICBcclxuICByZXR1cm4gbWF0Y2hlcztcclxufVxyXG5cclxuLyoqXHJcbiAqIFVuZXNjYXBlIHRleHRcclxuICovXHJcbmV4cG9ydCBmdW5jdGlvbiB1bmVzY2FwZVRleHQodGV4dDogc3RyaW5nKTogc3RyaW5nIHtcclxuICByZXR1cm4gdGV4dC5yZXBsYWNlKC9cXFxcOjo6L2csICc6OjonKTtcclxufSIsICIvKipcclxuICogTWFya2Rvd24gUG9zdCBQcm9jZXNzb3JcclxuICogQXBwbGllcyBjbGFzc2VzIGJhc2VkIG9uIHBhcnNlZCBzb3VyY2UgaW5mb3JtYXRpb25cclxuICovXHJcblxyXG5pbXBvcnQgeyBNYXJrZG93blBvc3RQcm9jZXNzb3JDb250ZXh0LCBDb21wb25lbnQgfSBmcm9tICdvYnNpZGlhbic7XHJcbmltcG9ydCB7IFxyXG4gIHBhcnNlU291cmNlLCBcclxuICBwYXJzZUlubGluZVRleHQsIFxyXG4gIHVuZXNjYXBlVGV4dCxcclxuICBwYXJzZUNsYXNzZXMsXHJcbiAgU291cmNlUGFyc2VSZXN1bHQsIFxyXG4gIENsYXNzSW5mbyxcclxuICBCbG9ja0luZm8gXHJcbn0gZnJvbSAnLi9wYXJzZXInO1xyXG5cclxuLyoqXHJcbiAqIEdldCB0ZXh0IGNvbnRlbnQgd2l0aG91dCBTVkcvY29sbGFwc2UgaW5kaWNhdG9yc1xyXG4gKi9cclxuZnVuY3Rpb24gZ2V0Q2xlYW5UZXh0KGVsOiBFbGVtZW50KTogc3RyaW5nIHtcclxuICBjb25zdCBjbG9uZSA9IGVsLmNsb25lTm9kZSh0cnVlKSBhcyBFbGVtZW50O1xyXG4gIGNsb25lLnF1ZXJ5U2VsZWN0b3JBbGwoJ3N2ZywgLmNvbGxhcHNlLWluZGljYXRvciwgLmhlYWRpbmctY29sbGFwc2UtaW5kaWNhdG9yLCAubGlzdC1idWxsZXQsIGlucHV0JykuZm9yRWFjaChlID0+IGUucmVtb3ZlKCkpO1xyXG4gIHJldHVybiBjbG9uZS50ZXh0Q29udGVudCB8fCAnJztcclxufVxyXG5cclxuLyoqXHJcbiAqIFJlbW92ZSA6OjogbWFya2VyIGFuZCBjbGFzc2VzIGZyb20gdGV4dCBjb250ZW50XHJcbiAqL1xyXG5mdW5jdGlvbiByZW1vdmVNYXJrZXJGcm9tVGV4dCh0ZXh0OiBzdHJpbmcpOiBzdHJpbmcge1xyXG4gIC8vIFJlbW92ZSA6OjogY2xhc3MxIDogY2xhc3MyIGF0IHRoZSBlbmRcclxuICByZXR1cm4gdGV4dC5yZXBsYWNlKC9cXHMqOjo6XFxzKltcXHdcXHM6Li1dKiQvLCAnJykudHJpbSgpO1xyXG59XHJcblxyXG4vKipcclxuICogUmVtb3ZlIDo6OiBtYXJrZXIgZnJvbSBhbiBlbGVtZW50J3MgdGV4dCBub2Rlc1xyXG4gKi9cclxuZnVuY3Rpb24gcmVtb3ZlTWFya2VyRnJvbUVsZW1lbnQoZWw6IEVsZW1lbnQpOiB2b2lkIHtcclxuICBjb25zdCB3YWxrZXIgPSBkb2N1bWVudC5jcmVhdGVUcmVlV2Fsa2VyKGVsLCBOb2RlRmlsdGVyLlNIT1dfVEVYVCk7XHJcbiAgY29uc3QgdGV4dE5vZGVzOiBUZXh0W10gPSBbXTtcclxuICBsZXQgbm9kZTogVGV4dCB8IG51bGw7XHJcbiAgXHJcbiAgd2hpbGUgKChub2RlID0gd2Fsa2VyLm5leHROb2RlKCkgYXMgVGV4dCB8IG51bGwpKSB7XHJcbiAgICB0ZXh0Tm9kZXMucHVzaChub2RlKTtcclxuICB9XHJcbiAgXHJcbiAgZm9yIChjb25zdCB0ZXh0Tm9kZSBvZiB0ZXh0Tm9kZXMpIHtcclxuICAgIGNvbnN0IHRleHQgPSB0ZXh0Tm9kZS50ZXh0Q29udGVudCB8fCAnJztcclxuICAgIC8vIFJlbW92ZSA6OjogYW5kIGV2ZXJ5dGhpbmcgYWZ0ZXIgKGNsYXNzIGRlZmluaXRpb25zKVxyXG4gICAgLy8gQWxzbyBoYW5kbGUgPGJyPjo6OiBwYXR0ZXJuXHJcbiAgICBjb25zdCBuZXdUZXh0ID0gdGV4dFxyXG4gICAgICAucmVwbGFjZSgvXFxzKjo6OlxccypbXFx3XFxzOi4tXSokLywgJycpXHJcbiAgICAgIC5yZXBsYWNlKC9eXFxzKjo6OlxccyokLywgJycpOyAvLyBSZW1vdmUgc3RhbmRhbG9uZSA6OjpcclxuICAgIFxyXG4gICAgaWYgKG5ld1RleHQgIT09IHRleHQpIHtcclxuICAgICAgdGV4dE5vZGUudGV4dENvbnRlbnQgPSBuZXdUZXh0O1xyXG4gICAgfVxyXG4gIH1cclxuICBcclxuICAvLyBBbHNvIHJlbW92ZSBhbnkgPGJyPiBmb2xsb3dlZCBieSBlbXB0eSB0ZXh0IG9yIGp1c3QgOjo6XHJcbiAgY29uc3QgYnJzID0gZWwucXVlcnlTZWxlY3RvckFsbCgnYnInKTtcclxuICBicnMuZm9yRWFjaChiciA9PiB7XHJcbiAgICBjb25zdCBuZXh0ID0gYnIubmV4dFNpYmxpbmc7XHJcbiAgICBpZiAobmV4dD8ubm9kZVR5cGUgPT09IE5vZGUuVEVYVF9OT0RFKSB7XHJcbiAgICAgIGNvbnN0IG5leHRUZXh0ID0gbmV4dC50ZXh0Q29udGVudD8udHJpbSgpIHx8ICcnO1xyXG4gICAgICBpZiAobmV4dFRleHQgPT09ICc6OjonIHx8IG5leHRUZXh0ID09PSAnJykge1xyXG4gICAgICAgIG5leHQudGV4dENvbnRlbnQgPSAnJztcclxuICAgICAgfVxyXG4gICAgfVxyXG4gIH0pO1xyXG59XHJcblxyXG4vKipcclxuICogRXh0cmFjdCBjbGFzc2VzIGZyb20gdGV4dCBlbmRpbmcgd2l0aCA6OjogY2xhc3MxIDogY2xhc3MyXHJcbiAqL1xyXG5mdW5jdGlvbiBleHRyYWN0Q2xhc3Nlc0Zyb21UZXh0KHRleHQ6IHN0cmluZyk6IHN0cmluZ1tdIHwgbnVsbCB7XHJcbiAgY29uc3QgbWF0Y2ggPSB0ZXh0Lm1hdGNoKC86OjpcXHMqKFtcXHctXSsoPzpcXHMqOlxccypbXFx3LV0rKSopXFxzKiQvKTtcclxuICBpZiAobWF0Y2gpIHtcclxuICAgIHJldHVybiBwYXJzZUNsYXNzZXMobWF0Y2hbMV0pO1xyXG4gIH1cclxuICByZXR1cm4gbnVsbDtcclxufVxyXG5cclxuLyoqXHJcbiAqIFBvc3QgUHJvY2Vzc29yIENsYXNzXHJcbiAqL1xyXG5leHBvcnQgY2xhc3MgQ3VzdG9tQ2xhc3NQb3N0UHJvY2Vzc29yIHtcclxuICBwcml2YXRlIGNvbXBvbmVudDogQ29tcG9uZW50O1xyXG5cclxuICBjb25zdHJ1Y3Rvcihjb21wb25lbnQ6IENvbXBvbmVudCkge1xyXG4gICAgdGhpcy5jb21wb25lbnQgPSBjb21wb25lbnQ7XHJcbiAgfVxyXG5cclxuICBwcm9jZXNzKGVsOiBIVE1MRWxlbWVudCwgY3R4OiBNYXJrZG93blBvc3RQcm9jZXNzb3JDb250ZXh0KTogdm9pZCB7XHJcbiAgICBjb25zdCBpbmZvID0gY3R4LmdldFNlY3Rpb25JbmZvKGVsKTtcclxuICAgIFxyXG4gICAgaWYgKGluZm8pIHtcclxuICAgICAgY29uc3QgeyB0ZXh0LCBsaW5lU3RhcnQsIGxpbmVFbmQgfSA9IGluZm87XHJcbiAgICAgIGNvbnN0IHBhcnNlUmVzdWx0ID0gcGFyc2VTb3VyY2UodGV4dCk7XHJcbiAgICAgIFxyXG4gICAgICAvLyBTa2lwIGlmIGluc2lkZSBhIGNvZGUgYmxvY2tcclxuICAgICAgaWYgKHBhcnNlUmVzdWx0LmNvZGVCbG9ja0xpbmVzLmhhcyhsaW5lU3RhcnQpKSB7XHJcbiAgICAgICAgcmV0dXJuO1xyXG4gICAgICB9XHJcbiAgICAgIFxyXG4gICAgICAvLyBQcm9jZXNzIGJhc2VkIG9uIHNvdXJjZSBpbmZvXHJcbiAgICAgIHRoaXMucHJvY2Vzc1dpdGhTb3VyY2UoZWwsIGxpbmVTdGFydCwgbGluZUVuZCwgcGFyc2VSZXN1bHQsIHRleHQpO1xyXG4gICAgfVxyXG4gICAgXHJcbiAgICAvLyBBbHdheXMgZG8gRE9NLWJhc2VkIHByb2Nlc3NpbmcgZm9yIGxpc3QgaXRlbXNcclxuICAgIHRoaXMucHJvY2Vzc0xpc3RJdGVtcyhlbCk7XHJcbiAgICBcclxuICAgIC8vIFByb2Nlc3MgaW5saW5lIHN5bnRheFxyXG4gICAgdGhpcy5wcm9jZXNzSW5saW5lcyhlbCk7XHJcbiAgICBcclxuICAgIC8vIENsZWFuIHVwIGJsb2NrIG1hcmtlcnMgZnJvbSBjb250ZW50XHJcbiAgICB0aGlzLmNsZWFudXBCbG9ja01hcmtlcnMoZWwpO1xyXG4gICAgXHJcbiAgICAvLyBVbmVzY2FwZSBtYXJrZXJzXHJcbiAgICB0aGlzLnVuZXNjYXBlTWFya2VycyhlbCk7XHJcbiAgfVxyXG5cclxuICAvKipcclxuICAgKiBQcm9jZXNzIGVsZW1lbnQgYmFzZWQgb24gc291cmNlIGxpbmUgaW5mb1xyXG4gICAqL1xyXG4gIHByaXZhdGUgcHJvY2Vzc1dpdGhTb3VyY2UoXHJcbiAgICBlbDogSFRNTEVsZW1lbnQsXHJcbiAgICBsaW5lU3RhcnQ6IG51bWJlcixcclxuICAgIGxpbmVFbmQ6IG51bWJlcixcclxuICAgIHJlc3VsdDogU291cmNlUGFyc2VSZXN1bHQsXHJcbiAgICBmdWxsVGV4dDogc3RyaW5nXHJcbiAgKTogdm9pZCB7XHJcbiAgICBjb25zdCBsaW5lSW5mbyA9IHJlc3VsdC5saW5lSW5mby5nZXQobGluZVN0YXJ0KTtcclxuICAgIFxyXG4gICAgLy8gQ2hlY2sgaWYgZWxlbWVudCBpcyBpbnNpZGUgYSBibG9ja1xyXG4gICAgZm9yIChjb25zdCBibG9jayBvZiByZXN1bHQuYmxvY2tzKSB7XHJcbiAgICAgIGlmIChsaW5lU3RhcnQgPj0gYmxvY2suc3RhcnRMaW5lICYmIGxpbmVFbmQgPD0gYmxvY2suZW5kTGluZSkge1xyXG4gICAgICAgIHRoaXMuYXBwbHlCbG9ja0NvbnRlbnRDbGFzc2VzKGVsLCBibG9jaywgbGluZVN0YXJ0ID09PSBibG9jay5zdGFydExpbmUsIGxpbmVFbmQgPj0gYmxvY2suZW5kTGluZSk7XHJcbiAgICAgICAgcmV0dXJuO1xyXG4gICAgICB9XHJcbiAgICB9XHJcbiAgICBcclxuICAgIGlmICghbGluZUluZm8pIHJldHVybjtcclxuICAgIFxyXG4gICAgc3dpdGNoIChsaW5lSW5mby50eXBlKSB7XHJcbiAgICAgIGNhc2UgJ2hlYWRlcic6XHJcbiAgICAgICAgdGhpcy5wcm9jZXNzSGVhZGVyKGVsLCBsaW5lSW5mbyk7XHJcbiAgICAgICAgYnJlYWs7XHJcbiAgICAgICAgXHJcbiAgICAgIGNhc2UgJ2NhbGxvdXQnOlxyXG4gICAgICAgIHRoaXMucHJvY2Vzc0NhbGxvdXQoZWwsIGxpbmVJbmZvKTtcclxuICAgICAgICBicmVhaztcclxuICAgICAgICBcclxuICAgICAgY2FzZSAnY29kZS1ibG9jayc6XHJcbiAgICAgICAgdGhpcy5wcm9jZXNzQ29kZUJsb2NrKGVsLCBsaW5lSW5mbyk7XHJcbiAgICAgICAgYnJlYWs7XHJcbiAgICAgICAgXHJcbiAgICAgIGNhc2UgJ2Jsb2NrLXN0YXJ0JzpcclxuICAgICAgICB0aGlzLmhpZGVNYXJrZXIoZWwpO1xyXG4gICAgICAgIGVsLnNldEF0dHJpYnV0ZSgnZGF0YS1jY3MtYmxvY2stc3RhcnQnLCBsaW5lSW5mby5jbGFzc2VzLmpvaW4oJyAnKSk7XHJcbiAgICAgICAgYnJlYWs7XHJcbiAgICAgICAgXHJcbiAgICAgIGNhc2UgJ2Jsb2NrLWVuZCc6XHJcbiAgICAgICAgdGhpcy5oaWRlTWFya2VyKGVsKTtcclxuICAgICAgICBicmVhaztcclxuICAgIH1cclxuICB9XHJcblxyXG4gIC8qKlxyXG4gICAqIFByb2Nlc3MgYWxsIGxpc3QgaXRlbXMgaW4gdGhlIGVsZW1lbnQgKERPTS1iYXNlZClcclxuICAgKi9cclxuICBwcml2YXRlIHByb2Nlc3NMaXN0SXRlbXMoZWw6IEhUTUxFbGVtZW50KTogdm9pZCB7XHJcbiAgICAvLyBGaW5kIGFsbCBsaXN0IGl0ZW1zXHJcbiAgICBjb25zdCBsaXN0SXRlbXMgPSBlbC5xdWVyeVNlbGVjdG9yQWxsKCdsaScpO1xyXG4gICAgXHJcbiAgICBsaXN0SXRlbXMuZm9yRWFjaChsaSA9PiB7XHJcbiAgICAgIC8vIFNraXAgaWYgYWxyZWFkeSBwcm9jZXNzZWRcclxuICAgICAgaWYgKGxpLmhhc0F0dHJpYnV0ZSgnZGF0YS1jY3MtcHJvY2Vzc2VkJykpIHJldHVybjtcclxuICAgICAgXHJcbiAgICAgIGNvbnN0IHRleHQgPSBnZXRDbGVhblRleHQobGkpO1xyXG4gICAgICBcclxuICAgICAgLy8gQ2hlY2sgZm9yIDo6OiBjbGFzcyBwYXR0ZXJuIGF0IHRoZSBlbmRcclxuICAgICAgY29uc3QgY2xhc3NlcyA9IGV4dHJhY3RDbGFzc2VzRnJvbVRleHQodGV4dCk7XHJcbiAgICAgIFxyXG4gICAgICBpZiAoY2xhc3NlcyAmJiBjbGFzc2VzLmxlbmd0aCA+IDApIHtcclxuICAgICAgICAvLyBBcHBseSBjbGFzc2VzXHJcbiAgICAgICAgbGkuY2xhc3NMaXN0LmFkZCguLi5jbGFzc2VzKTtcclxuICAgICAgICBsaS5zZXRBdHRyaWJ1dGUoJ2RhdGEtY2NzLXByb2Nlc3NlZCcsICd0cnVlJyk7XHJcbiAgICAgICAgXHJcbiAgICAgICAgLy8gUmVtb3ZlIHRoZSBtYXJrZXIgZnJvbSB0aGUgdGV4dFxyXG4gICAgICAgIHJlbW92ZU1hcmtlckZyb21FbGVtZW50KGxpKTtcclxuICAgICAgfVxyXG4gICAgfSk7XHJcbiAgfVxyXG5cclxuICAvKipcclxuICAgKiBQcm9jZXNzIGhlYWRlcjogIyBIZWFkZXIgOjo6IGNsYXNzXHJcbiAgICovXHJcbiAgcHJpdmF0ZSBwcm9jZXNzSGVhZGVyKGVsOiBIVE1MRWxlbWVudCwgaW5mbzogQ2xhc3NJbmZvKTogdm9pZCB7XHJcbiAgICBjb25zdCBoZWFkZXIgPSBlbC5xdWVyeVNlbGVjdG9yKCdoMSwgaDIsIGgzLCBoNCwgaDUsIGg2Jyk7XHJcbiAgICBpZiAoaGVhZGVyKSB7XHJcbiAgICAgIGhlYWRlci5jbGFzc0xpc3QuYWRkKC4uLmluZm8uY2xhc3Nlcyk7XHJcbiAgICAgIHJlbW92ZU1hcmtlckZyb21FbGVtZW50KGhlYWRlcik7XHJcbiAgICB9XHJcbiAgfVxyXG5cclxuICAvKipcclxuICAgKiBQcm9jZXNzIGNhbGxvdXQ6ID4gWyF0eXBlXSBUaXRsZSA6OjogY2xhc3NcclxuICAgKi9cclxuICBwcml2YXRlIHByb2Nlc3NDYWxsb3V0KGVsOiBIVE1MRWxlbWVudCwgaW5mbzogQ2xhc3NJbmZvKTogdm9pZCB7XHJcbiAgICBjb25zdCBjYWxsb3V0ID0gZWwucXVlcnlTZWxlY3RvcignLmNhbGxvdXQnKTtcclxuICAgIGlmIChjYWxsb3V0KSB7XHJcbiAgICAgIGNhbGxvdXQuY2xhc3NMaXN0LmFkZCguLi5pbmZvLmNsYXNzZXMpO1xyXG4gICAgICBcclxuICAgICAgLy8gUmVtb3ZlIG1hcmtlciBmcm9tIHRpdGxlXHJcbiAgICAgIGNvbnN0IHRpdGxlSW5uZXIgPSBjYWxsb3V0LnF1ZXJ5U2VsZWN0b3IoJy5jYWxsb3V0LXRpdGxlLWlubmVyJyk7XHJcbiAgICAgIGlmICh0aXRsZUlubmVyKSB7XHJcbiAgICAgICAgcmVtb3ZlTWFya2VyRnJvbUVsZW1lbnQodGl0bGVJbm5lcik7XHJcbiAgICAgIH1cclxuICAgIH1cclxuICB9XHJcblxyXG4gIC8qKlxyXG4gICAqIFByb2Nlc3MgY29kZSBibG9jazogYGBgbGFuZyA6OjogY2xhc3NcclxuICAgKi9cclxuICBwcml2YXRlIHByb2Nlc3NDb2RlQmxvY2soZWw6IEhUTUxFbGVtZW50LCBpbmZvOiBDbGFzc0luZm8pOiB2b2lkIHtcclxuICAgIGNvbnN0IHByZSA9IGVsLnF1ZXJ5U2VsZWN0b3IoJ3ByZScpO1xyXG4gICAgaWYgKHByZSkge1xyXG4gICAgICBwcmUuY2xhc3NMaXN0LmFkZCguLi5pbmZvLmNsYXNzZXMpO1xyXG4gICAgfVxyXG4gIH1cclxuXHJcbiAgLyoqXHJcbiAgICogSGlkZSBibG9jayBtYXJrZXIgZWxlbWVudHNcclxuICAgKi9cclxuICBwcml2YXRlIGhpZGVNYXJrZXIoZWw6IEhUTUxFbGVtZW50KTogdm9pZCB7XHJcbiAgICBlbC5zdHlsZS5kaXNwbGF5ID0gJ25vbmUnO1xyXG4gICAgZWwuY2xhc3NMaXN0LmFkZCgnY2NzLW1hcmtlcicpO1xyXG4gIH1cclxuXHJcbiAgLyoqXHJcbiAgICogQXBwbHkgY2xhc3NlcyB0byBjb250ZW50IGluc2lkZSBhIGJsb2NrXHJcbiAgICovXHJcbiAgcHJpdmF0ZSBhcHBseUJsb2NrQ29udGVudENsYXNzZXMoXHJcbiAgICBlbDogSFRNTEVsZW1lbnQsIFxyXG4gICAgYmxvY2s6IEJsb2NrSW5mbywgXHJcbiAgICBpc1N0YXJ0OiBib29sZWFuLFxyXG4gICAgY29udGFpbnNFbmQ6IGJvb2xlYW5cclxuICApOiB2b2lkIHtcclxuICAgIC8vIElmIHRoaXMgaXMgdGhlIHN0YXJ0IG1hcmtlciwgaGlkZSBpdFxyXG4gICAgaWYgKGlzU3RhcnQpIHtcclxuICAgICAgdGhpcy5oaWRlTWFya2VyKGVsKTtcclxuICAgICAgZWwuc2V0QXR0cmlidXRlKCdkYXRhLWNjcy1ibG9jay1zdGFydCcsIGJsb2NrLmNsYXNzZXMuam9pbignICcpKTtcclxuICAgICAgcmV0dXJuO1xyXG4gICAgfVxyXG4gICAgXHJcbiAgICAvLyBBcHBseSBjbGFzc2VzIGJhc2VkIG9uIGJsb2NrIHR5cGVcclxuICAgIHN3aXRjaCAoYmxvY2sudHlwZSkge1xyXG4gICAgICBjYXNlICd0YWJsZSc6XHJcbiAgICAgICAgY29uc3QgdGFibGUgPSBlbC5xdWVyeVNlbGVjdG9yKCd0YWJsZScpO1xyXG4gICAgICAgIGlmICh0YWJsZSkge1xyXG4gICAgICAgICAgdGFibGUuY2xhc3NMaXN0LmFkZCguLi5ibG9jay5jbGFzc2VzKTtcclxuICAgICAgICB9XHJcbiAgICAgICAgYnJlYWs7XHJcbiAgICAgICAgXHJcbiAgICAgIGNhc2UgJ2xpc3QnOlxyXG4gICAgICAgIGNvbnN0IGxpc3QgPSBlbC5xdWVyeVNlbGVjdG9yKCd1bCwgb2wnKTtcclxuICAgICAgICBpZiAobGlzdCkge1xyXG4gICAgICAgICAgbGlzdC5jbGFzc0xpc3QuYWRkKC4uLmJsb2NrLmNsYXNzZXMpO1xyXG4gICAgICAgIH1cclxuICAgICAgICBicmVhaztcclxuICAgICAgICBcclxuICAgICAgZGVmYXVsdDpcclxuICAgICAgICBlbC5jbGFzc0xpc3QuYWRkKC4uLmJsb2NrLmNsYXNzZXMpO1xyXG4gICAgfVxyXG4gICAgXHJcbiAgICAvLyBJZiB0aGlzIGVsZW1lbnQgY29udGFpbnMgdGhlIGJsb2NrIGVuZCwgY2xlYW4gaXQgdXBcclxuICAgIGlmIChjb250YWluc0VuZCkge1xyXG4gICAgICB0aGlzLnJlbW92ZUJsb2NrRW5kTWFya2VyKGVsKTtcclxuICAgIH1cclxuICB9XHJcblxyXG4gIC8qKlxyXG4gICAqIFJlbW92ZSBibG9jayBlbmQgbWFya2VyIGZyb20gZWxlbWVudCBjb250ZW50XHJcbiAgICovXHJcbiAgcHJpdmF0ZSByZW1vdmVCbG9ja0VuZE1hcmtlcihlbDogSFRNTEVsZW1lbnQpOiB2b2lkIHtcclxuICAgIC8vIEZpbmQgYW5kIHJlbW92ZSA6OjogdGhhdCdzIHRoZSBibG9jayBjbG9zaW5nIG1hcmtlclxyXG4gICAgY29uc3Qgd2Fsa2VyID0gZG9jdW1lbnQuY3JlYXRlVHJlZVdhbGtlcihlbCwgTm9kZUZpbHRlci5TSE9XX1RFWFQpO1xyXG4gICAgY29uc3QgdGV4dE5vZGVzOiBUZXh0W10gPSBbXTtcclxuICAgIGxldCBub2RlOiBUZXh0IHwgbnVsbDtcclxuICAgIFxyXG4gICAgd2hpbGUgKChub2RlID0gd2Fsa2VyLm5leHROb2RlKCkgYXMgVGV4dCB8IG51bGwpKSB7XHJcbiAgICAgIHRleHROb2Rlcy5wdXNoKG5vZGUpO1xyXG4gICAgfVxyXG4gICAgXHJcbiAgICAvLyBDaGVjayB0aGUgbGFzdCBmZXcgdGV4dCBub2RlcyBmb3IgOjo6XHJcbiAgICBmb3IgKGxldCBpID0gdGV4dE5vZGVzLmxlbmd0aCAtIDE7IGkgPj0gMDsgaS0tKSB7XHJcbiAgICAgIGNvbnN0IHRleHROb2RlID0gdGV4dE5vZGVzW2ldO1xyXG4gICAgICBjb25zdCB0ZXh0ID0gdGV4dE5vZGUudGV4dENvbnRlbnQgfHwgJyc7XHJcbiAgICAgIFxyXG4gICAgICAvLyBSZW1vdmUgc3RhbmRhbG9uZSA6OjpcclxuICAgICAgaWYgKC9eXFxzKjo6OlxccyokLy50ZXN0KHRleHQpKSB7XHJcbiAgICAgICAgdGV4dE5vZGUudGV4dENvbnRlbnQgPSAnJztcclxuICAgICAgICBcclxuICAgICAgICAvLyBBbHNvIHJlbW92ZSBwcmVjZWRpbmcgPGJyPiBpZiBwcmVzZW50XHJcbiAgICAgICAgY29uc3QgcHJldiA9IHRleHROb2RlLnByZXZpb3VzU2libGluZztcclxuICAgICAgICBpZiAocHJldj8ubm9kZU5hbWUgPT09ICdCUicpIHtcclxuICAgICAgICAgIHByZXYucmVtb3ZlKCk7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIGJyZWFrO1xyXG4gICAgICB9XHJcbiAgICAgIFxyXG4gICAgICAvLyBSZW1vdmUgOjo6IGF0IGVuZCBvZiB0ZXh0XHJcbiAgICAgIGlmICh0ZXh0LmluY2x1ZGVzKCc6OjonKSkge1xyXG4gICAgICAgIHRleHROb2RlLnRleHRDb250ZW50ID0gdGV4dC5yZXBsYWNlKC9cXHMqOjo6XFxzKiQvLCAnJyk7XHJcbiAgICAgICAgYnJlYWs7XHJcbiAgICAgIH1cclxuICAgIH1cclxuICB9XHJcblxyXG4gIC8qKlxyXG4gICAqIENsZWFuIHVwIGFueSByZW1haW5pbmcgYmxvY2sgbWFya2Vyc1xyXG4gICAqL1xyXG4gIHByaXZhdGUgY2xlYW51cEJsb2NrTWFya2VycyhlbDogSFRNTEVsZW1lbnQpOiB2b2lkIHtcclxuICAgIGlmIChlbC5jbGFzc0xpc3QuY29udGFpbnMoJ2Njcy1tYXJrZXInKSkgcmV0dXJuO1xyXG4gICAgXHJcbiAgICBjb25zdCB3YWxrZXIgPSBkb2N1bWVudC5jcmVhdGVUcmVlV2Fsa2VyKGVsLCBOb2RlRmlsdGVyLlNIT1dfVEVYVCk7XHJcbiAgICBjb25zdCB0ZXh0Tm9kZXM6IFRleHRbXSA9IFtdO1xyXG4gICAgbGV0IG5vZGU6IFRleHQgfCBudWxsO1xyXG4gICAgXHJcbiAgICB3aGlsZSAoKG5vZGUgPSB3YWxrZXIubmV4dE5vZGUoKSBhcyBUZXh0IHwgbnVsbCkpIHtcclxuICAgICAgdGV4dE5vZGVzLnB1c2gobm9kZSk7XHJcbiAgICB9XHJcbiAgICBcclxuICAgIGZvciAoY29uc3QgdGV4dE5vZGUgb2YgdGV4dE5vZGVzKSB7XHJcbiAgICAgIGNvbnN0IHRleHQgPSB0ZXh0Tm9kZS50ZXh0Q29udGVudCB8fCAnJztcclxuICAgICAgXHJcbiAgICAgIC8vIFJlbW92ZSBzdGFuZGFsb25lIDo6OiAoYmxvY2sgbWFya2VycylcclxuICAgICAgaWYgKC9eXFxzKjo6OlxccyokLy50ZXN0KHRleHQudHJpbSgpKSkge1xyXG4gICAgICAgIC8vIENoZWNrIGlmIHRoaXMgaXMganVzdCBhIGNsb3NpbmcgbWFya2VyLCBub3QgaW5saW5lIHN5bnRheFxyXG4gICAgICAgIGNvbnN0IHBhcmVudCA9IHRleHROb2RlLnBhcmVudEVsZW1lbnQ7XHJcbiAgICAgICAgaWYgKHBhcmVudCAmJiAhcGFyZW50LmNsb3Nlc3QoJy5jY3MtaW5saW5lJykpIHtcclxuICAgICAgICAgIHRleHROb2RlLnRleHRDb250ZW50ID0gJyc7XHJcbiAgICAgICAgICBcclxuICAgICAgICAgIC8vIFJlbW92ZSBwcmVjZWRpbmcgPGJyPlxyXG4gICAgICAgICAgY29uc3QgcHJldiA9IHRleHROb2RlLnByZXZpb3VzU2libGluZztcclxuICAgICAgICAgIGlmIChwcmV2Py5ub2RlTmFtZSA9PT0gJ0JSJykge1xyXG4gICAgICAgICAgICBwcmV2LnJlbW92ZSgpO1xyXG4gICAgICAgICAgfVxyXG4gICAgICAgIH1cclxuICAgICAgfVxyXG4gICAgfVxyXG4gIH1cclxuXHJcbiAgLyoqXHJcbiAgICogUHJvY2VzcyBpbmxpbmUgc3ludGF4XHJcbiAgICovXHJcbiAgcHJpdmF0ZSBwcm9jZXNzSW5saW5lcyhlbDogSFRNTEVsZW1lbnQpOiB2b2lkIHtcclxuICAgIGlmIChlbC5jbGFzc0xpc3QuY29udGFpbnMoJ2Njcy1tYXJrZXInKSkgcmV0dXJuO1xyXG4gICAgXHJcbiAgICAvLyBQcm9jZXNzIGlubGluZSBjb2RlOiBgY29kZWAgOjo6IGNsYXNzXHJcbiAgICB0aGlzLnByb2Nlc3NJbmxpbmVDb2RlKGVsKTtcclxuICAgIFxyXG4gICAgLy8gUHJvY2VzcyBpbmxpbmUgdGV4dDogOjo6IGNsYXNzIDogY29udGVudCA6OjpcclxuICAgIHRoaXMucHJvY2Vzc0lubGluZVRleHQoZWwpO1xyXG4gIH1cclxuXHJcbiAgLyoqXHJcbiAgICogUHJvY2VzcyBpbmxpbmUgY29kZSB3aXRoIGNsYXNzZXNcclxuICAgKi9cclxuICBwcml2YXRlIHByb2Nlc3NJbmxpbmVDb2RlKGVsOiBIVE1MRWxlbWVudCk6IHZvaWQge1xyXG4gICAgY29uc3QgY29kZUVsZW1lbnRzID0gZWwucXVlcnlTZWxlY3RvckFsbCgnY29kZTpub3QocHJlIGNvZGUpJyk7XHJcbiAgICBcclxuICAgIGNvZGVFbGVtZW50cy5mb3JFYWNoKGNvZGUgPT4ge1xyXG4gICAgICBjb25zdCBuZXh0U2libGluZyA9IGNvZGUubmV4dFNpYmxpbmc7XHJcbiAgICAgIGlmIChuZXh0U2libGluZz8ubm9kZVR5cGUgIT09IE5vZGUuVEVYVF9OT0RFKSByZXR1cm47XHJcbiAgICAgIFxyXG4gICAgICBjb25zdCB0ZXh0ID0gbmV4dFNpYmxpbmcudGV4dENvbnRlbnQgfHwgJyc7XHJcbiAgICAgIFxyXG4gICAgICAvLyBDaGVjayBmb3IgOjo6IGNsYXNzIHBhdHRlcm4gKG5vdCBlc2NhcGVkKVxyXG4gICAgICBjb25zdCBtYXRjaCA9IHRleHQubWF0Y2goL15cXHMqOjo6XFxzKihbXFx3LV0rKD86XFxzKjpcXHMqW1xcdy1dKykqKS8pO1xyXG4gICAgICBpZiAoIW1hdGNoKSByZXR1cm47XHJcbiAgICAgIFxyXG4gICAgICAvLyBTa2lwIGlmIGVzY2FwZWRcclxuICAgICAgaWYgKHRleHQudHJpbVN0YXJ0KCkuc3RhcnRzV2l0aCgnXFxcXDo6OicpKSByZXR1cm47XHJcbiAgICAgIFxyXG4gICAgICBjb25zdCBjbGFzc2VzID0gcGFyc2VDbGFzc2VzKG1hdGNoWzFdKTtcclxuICAgICAgXHJcbiAgICAgIGlmIChjbGFzc2VzLmxlbmd0aCA+IDApIHtcclxuICAgICAgICBjb2RlLmNsYXNzTGlzdC5hZGQoLi4uY2xhc3Nlcyk7XHJcbiAgICAgICAgbmV4dFNpYmxpbmcudGV4dENvbnRlbnQgPSB0ZXh0LnNsaWNlKG1hdGNoWzBdLmxlbmd0aCk7XHJcbiAgICAgIH1cclxuICAgIH0pO1xyXG4gIH1cclxuXHJcbiAgLyoqXHJcbiAgICogUHJvY2VzcyBpbmxpbmUgdGV4dCBzeW50YXg6IDo6OiBjbGFzcyA6IGNvbnRlbnQgOjo6XHJcbiAgICovXHJcbiAgcHJpdmF0ZSBwcm9jZXNzSW5saW5lVGV4dChlbDogSFRNTEVsZW1lbnQpOiB2b2lkIHtcclxuICAgIGNvbnN0IHdhbGtlciA9IGRvY3VtZW50LmNyZWF0ZVRyZWVXYWxrZXIoXHJcbiAgICAgIGVsLFxyXG4gICAgICBOb2RlRmlsdGVyLlNIT1dfVEVYVCxcclxuICAgICAge1xyXG4gICAgICAgIGFjY2VwdE5vZGU6IChub2RlKSA9PiB7XHJcbiAgICAgICAgICBjb25zdCB0ZXh0ID0gbm9kZS50ZXh0Q29udGVudCB8fCAnJztcclxuICAgICAgICAgIGNvbnN0IHBhcmVudCA9IG5vZGUucGFyZW50RWxlbWVudDtcclxuICAgICAgICAgIFxyXG4gICAgICAgICAgaWYgKCF0ZXh0LmluY2x1ZGVzKCc6OjonKSkgcmV0dXJuIE5vZGVGaWx0ZXIuRklMVEVSX1NLSVA7XHJcbiAgICAgICAgICBpZiAocGFyZW50Py5jbG9zZXN0KCcuY2NzLWlubGluZSwgLmNjcy1tYXJrZXIsIGNvZGUsIHByZSwgc3ZnJykpIHtcclxuICAgICAgICAgICAgcmV0dXJuIE5vZGVGaWx0ZXIuRklMVEVSX1NLSVA7XHJcbiAgICAgICAgICB9XHJcbiAgICAgICAgICBcclxuICAgICAgICAgIHJldHVybiBOb2RlRmlsdGVyLkZJTFRFUl9BQ0NFUFQ7XHJcbiAgICAgICAgfVxyXG4gICAgICB9XHJcbiAgICApO1xyXG5cclxuICAgIGNvbnN0IHRleHROb2RlczogVGV4dFtdID0gW107XHJcbiAgICBsZXQgbm9kZTogVGV4dCB8IG51bGw7XHJcbiAgICB3aGlsZSAoKG5vZGUgPSB3YWxrZXIubmV4dE5vZGUoKSBhcyBUZXh0IHwgbnVsbCkpIHtcclxuICAgICAgdGV4dE5vZGVzLnB1c2gobm9kZSk7XHJcbiAgICB9XHJcblxyXG4gICAgZm9yIChjb25zdCB0ZXh0Tm9kZSBvZiB0ZXh0Tm9kZXMpIHtcclxuICAgICAgY29uc3QgdGV4dCA9IHRleHROb2RlLnRleHRDb250ZW50IHx8ICcnO1xyXG4gICAgICBjb25zdCBtYXRjaGVzID0gcGFyc2VJbmxpbmVUZXh0KHRleHQpO1xyXG4gICAgICBcclxuICAgICAgaWYgKG1hdGNoZXMubGVuZ3RoID09PSAwKSBjb250aW51ZTtcclxuICAgICAgXHJcbiAgICAgIGNvbnN0IHBhcmVudCA9IHRleHROb2RlLnBhcmVudE5vZGU7XHJcbiAgICAgIGlmICghcGFyZW50KSBjb250aW51ZTtcclxuICAgICAgXHJcbiAgICAgIGNvbnN0IGZyYWdtZW50ID0gZG9jdW1lbnQuY3JlYXRlRG9jdW1lbnRGcmFnbWVudCgpO1xyXG4gICAgICBsZXQgbGFzdEluZGV4ID0gMDtcclxuICAgICAgXHJcbiAgICAgIGZvciAoY29uc3QgbWF0Y2ggb2YgbWF0Y2hlcykge1xyXG4gICAgICAgIGlmIChtYXRjaC5zdGFydCA+IGxhc3RJbmRleCkge1xyXG4gICAgICAgICAgZnJhZ21lbnQuYXBwZW5kQ2hpbGQoZG9jdW1lbnQuY3JlYXRlVGV4dE5vZGUodGV4dC5zbGljZShsYXN0SW5kZXgsIG1hdGNoLnN0YXJ0KSkpO1xyXG4gICAgICAgIH1cclxuICAgICAgICBcclxuICAgICAgICBjb25zdCBzcGFuID0gZG9jdW1lbnQuY3JlYXRlRWxlbWVudCgnc3BhbicpO1xyXG4gICAgICAgIHNwYW4uY2xhc3NOYW1lID0gWydjY3MtaW5saW5lJywgLi4ubWF0Y2guY2xhc3Nlc10uam9pbignICcpO1xyXG4gICAgICAgIHNwYW4udGV4dENvbnRlbnQgPSBtYXRjaC5jb250ZW50O1xyXG4gICAgICAgIGZyYWdtZW50LmFwcGVuZENoaWxkKHNwYW4pO1xyXG4gICAgICAgIFxyXG4gICAgICAgIGxhc3RJbmRleCA9IG1hdGNoLmVuZDtcclxuICAgICAgfVxyXG4gICAgICBcclxuICAgICAgaWYgKGxhc3RJbmRleCA8IHRleHQubGVuZ3RoKSB7XHJcbiAgICAgICAgZnJhZ21lbnQuYXBwZW5kQ2hpbGQoZG9jdW1lbnQuY3JlYXRlVGV4dE5vZGUodGV4dC5zbGljZShsYXN0SW5kZXgpKSk7XHJcbiAgICAgIH1cclxuICAgICAgXHJcbiAgICAgIHBhcmVudC5yZXBsYWNlQ2hpbGQoZnJhZ21lbnQsIHRleHROb2RlKTtcclxuICAgIH1cclxuICB9XHJcblxyXG4gIC8qKlxyXG4gICAqIFVuZXNjYXBlIFxcOjo6IG1hcmtlcnNcclxuICAgKi9cclxuICBwcml2YXRlIHVuZXNjYXBlTWFya2VycyhlbDogSFRNTEVsZW1lbnQpOiB2b2lkIHtcclxuICAgIGNvbnN0IHdhbGtlciA9IGRvY3VtZW50LmNyZWF0ZVRyZWVXYWxrZXIoZWwsIE5vZGVGaWx0ZXIuU0hPV19URVhUKTtcclxuICAgIGNvbnN0IG5vZGVzVG9DbGVhbjogVGV4dFtdID0gW107XHJcbiAgICBsZXQgbm9kZTogVGV4dCB8IG51bGw7XHJcbiAgICBcclxuICAgIHdoaWxlICgobm9kZSA9IHdhbGtlci5uZXh0Tm9kZSgpIGFzIFRleHQgfCBudWxsKSkge1xyXG4gICAgICBpZiAobm9kZS50ZXh0Q29udGVudD8uaW5jbHVkZXMoJ1xcXFw6OjonKSkge1xyXG4gICAgICAgIG5vZGVzVG9DbGVhbi5wdXNoKG5vZGUpO1xyXG4gICAgICB9XHJcbiAgICB9XHJcbiAgICBcclxuICAgIG5vZGVzVG9DbGVhbi5mb3JFYWNoKHRleHROb2RlID0+IHtcclxuICAgICAgdGV4dE5vZGUudGV4dENvbnRlbnQgPSB1bmVzY2FwZVRleHQodGV4dE5vZGUudGV4dENvbnRlbnQgfHwgJycpO1xyXG4gICAgfSk7XHJcbiAgfVxyXG59XHJcblxyXG4vKipcclxuICogQ3JlYXRlIHRoZSBwb3N0IHByb2Nlc3NvclxyXG4gKi9cclxuZXhwb3J0IGZ1bmN0aW9uIGNyZWF0ZVBvc3RQcm9jZXNzb3IoY29tcG9uZW50OiBDb21wb25lbnQpIHtcclxuICBjb25zdCBwcm9jZXNzb3IgPSBuZXcgQ3VzdG9tQ2xhc3NQb3N0UHJvY2Vzc29yKGNvbXBvbmVudCk7XHJcbiAgcmV0dXJuIChlbDogSFRNTEVsZW1lbnQsIGN0eDogTWFya2Rvd25Qb3N0UHJvY2Vzc29yQ29udGV4dCkgPT4ge1xyXG4gICAgcHJvY2Vzc29yLnByb2Nlc3MoZWwsIGN0eCk7XHJcbiAgfTtcclxufSIsICIvKipcclxuICogUGx1Z2luIFNldHRpbmdzXHJcbiAqL1xyXG5cclxuaW1wb3J0IHsgQXBwLCBQbHVnaW5TZXR0aW5nVGFiLCBTZXR0aW5nIH0gZnJvbSAnb2JzaWRpYW4nO1xyXG5pbXBvcnQgdHlwZSBDdXN0b21DbGFzc1BsdWdpbiBmcm9tICcuL21haW4nO1xyXG5cclxuZXhwb3J0IGludGVyZmFjZSBDdXN0b21DbGFzc1NldHRpbmdzIHtcclxuICBlbmFibGVMaXZlUHJldmlldzogYm9vbGVhbjtcclxuICBlbmFibGVSZWFkaW5nVmlldzogYm9vbGVhbjtcclxuICBzaG93Q2xhc3NMYWJlbHM6IGJvb2xlYW47XHJcbiAgY3VzdG9tQ1NTOiBzdHJpbmc7XHJcbn1cclxuXHJcbmV4cG9ydCBjb25zdCBERUZBVUxUX1NFVFRJTkdTOiBDdXN0b21DbGFzc1NldHRpbmdzID0ge1xyXG4gIGVuYWJsZUxpdmVQcmV2aWV3OiB0cnVlLFxyXG4gIGVuYWJsZVJlYWRpbmdWaWV3OiB0cnVlLFxyXG4gIHNob3dDbGFzc0xhYmVsczogdHJ1ZSxcclxuICBjdXN0b21DU1M6ICcnLFxyXG59O1xyXG5cclxuZXhwb3J0IGNsYXNzIEN1c3RvbUNsYXNzU2V0dGluZ1RhYiBleHRlbmRzIFBsdWdpblNldHRpbmdUYWIge1xyXG4gIHBsdWdpbjogQ3VzdG9tQ2xhc3NQbHVnaW47XHJcblxyXG4gIGNvbnN0cnVjdG9yKGFwcDogQXBwLCBwbHVnaW46IEN1c3RvbUNsYXNzUGx1Z2luKSB7XHJcbiAgICBzdXBlcihhcHAsIHBsdWdpbik7XHJcbiAgICB0aGlzLnBsdWdpbiA9IHBsdWdpbjtcclxuICB9XHJcblxyXG4gIGRpc3BsYXkoKTogdm9pZCB7XHJcbiAgICBjb25zdCB7IGNvbnRhaW5lckVsIH0gPSB0aGlzO1xyXG4gICAgY29udGFpbmVyRWwuZW1wdHkoKTtcclxuXHJcbiAgICBjb250YWluZXJFbC5jcmVhdGVFbCgnaDInLCB7IHRleHQ6ICdDdXN0b20gQ2xhc3MgU3ludGF4IFNldHRpbmdzJyB9KTtcclxuXHJcbiAgICAvLyBTeW50YXggUmVmZXJlbmNlXHJcbiAgICBjb250YWluZXJFbC5jcmVhdGVFbCgnaDMnLCB7IHRleHQ6ICdTeW50YXggUmVmZXJlbmNlJyB9KTtcclxuICAgIFxyXG4gICAgY29uc3Qgc3ludGF4UmVmID0gY29udGFpbmVyRWwuY3JlYXRlRGl2KHsgY2xzOiAnY2NzLXN5bnRheC1yZWZlcmVuY2UnIH0pO1xyXG4gICAgc3ludGF4UmVmLmlubmVySFRNTCA9IGBcclxuICAgICAgPGRpdiBzdHlsZT1cImJhY2tncm91bmQ6IHZhcigtLWJhY2tncm91bmQtc2Vjb25kYXJ5KTsgcGFkZGluZzogMWVtOyBib3JkZXItcmFkaXVzOiA4cHg7IG1hcmdpbi1ib3R0b206IDFlbTtcIj5cclxuICAgICAgICA8aDQgc3R5bGU9XCJtYXJnaW4tdG9wOiAwO1wiPkJsb2NrIFN5bnRheDwvaDQ+XHJcbiAgICAgICAgPHByZSBzdHlsZT1cImJhY2tncm91bmQ6IHZhcigtLWJhY2tncm91bmQtcHJpbWFyeSk7IHBhZGRpbmc6IDAuNWVtOyBib3JkZXItcmFkaXVzOiA0cHg7XCI+XHJcbjo6OiB3YXJuaW5nXHJcblRoaXMgY29udGVudCBnZXRzIHRoZSBcIndhcm5pbmdcIiBjbGFzc1xyXG46OjpcclxuXHJcbjo6OiBjYXJkIDogc2hhZG93IDogcm91bmRlZFxyXG5NdWx0aXBsZSBjbGFzc2VzIHNlcGFyYXRlZCBieSBjb2xvbnNcclxuOjo6PC9wcmU+XHJcbiAgICAgICAgXHJcbiAgICAgICAgPGg0PklubGluZSBTeW50YXg8L2g0PlxyXG4gICAgICAgIDxwcmUgc3R5bGU9XCJiYWNrZ3JvdW5kOiB2YXIoLS1iYWNrZ3JvdW5kLXByaW1hcnkpOyBwYWRkaW5nOiAwLjVlbTsgYm9yZGVyLXJhZGl1czogNHB4O1wiPlxyXG5UaGlzIGlzIDo6OiAuaGlnaGxpZ2h0IDogaGlnaGxpZ2h0ZWQgdGV4dCA6OjogaW4gYSBzZW50ZW5jZS5cclxuVXNlIDo6OiByZWQgOiBib2xkIDogaW1wb3J0YW50IHRleHQgOjo6IGZvciBlbXBoYXNpcy48L3ByZT5cclxuICAgICAgICBcclxuICAgICAgICA8aDQ+RXNjYXBpbmc8L2g0PlxyXG4gICAgICAgIDxwcmUgc3R5bGU9XCJiYWNrZ3JvdW5kOiB2YXIoLS1iYWNrZ3JvdW5kLXByaW1hcnkpOyBwYWRkaW5nOiAwLjVlbTsgYm9yZGVyLXJhZGl1czogNHB4O1wiPlxyXG5cXFxcOjo6IFRoaXMgd29uJ3QgYmUgcGFyc2VkIDo6OjwvcHJlPlxyXG4gICAgICA8L2Rpdj5cclxuICAgIGA7XHJcblxyXG4gICAgLy8gRW5hYmxlL0Rpc2FibGUgU2V0dGluZ3NcclxuICAgIG5ldyBTZXR0aW5nKGNvbnRhaW5lckVsKVxyXG4gICAgICAuc2V0TmFtZSgnRW5hYmxlIGluIExpdmUgUHJldmlldycpXHJcbiAgICAgIC5zZXREZXNjKCdTaG93IGRlY29yYXRpb25zIGluIHRoZSBlZGl0b3InKVxyXG4gICAgICAuYWRkVG9nZ2xlKCh0b2dnbGUpID0+XHJcbiAgICAgICAgdG9nZ2xlXHJcbiAgICAgICAgICAuc2V0VmFsdWUodGhpcy5wbHVnaW4uc2V0dGluZ3MuZW5hYmxlTGl2ZVByZXZpZXcpXHJcbiAgICAgICAgICAub25DaGFuZ2UoYXN5bmMgKHZhbHVlKSA9PiB7XHJcbiAgICAgICAgICAgIHRoaXMucGx1Z2luLnNldHRpbmdzLmVuYWJsZUxpdmVQcmV2aWV3ID0gdmFsdWU7XHJcbiAgICAgICAgICAgIGF3YWl0IHRoaXMucGx1Z2luLnNhdmVTZXR0aW5ncygpO1xyXG4gICAgICAgICAgfSlcclxuICAgICAgKTtcclxuXHJcbiAgICBuZXcgU2V0dGluZyhjb250YWluZXJFbClcclxuICAgICAgLnNldE5hbWUoJ0VuYWJsZSBpbiBSZWFkaW5nIFZpZXcnKVxyXG4gICAgICAuc2V0RGVzYygnUHJvY2VzcyBjdXN0b20gY2xhc3NlcyBpbiByZWFkaW5nIHZpZXcgYW5kIFBERiBleHBvcnQnKVxyXG4gICAgICAuYWRkVG9nZ2xlKCh0b2dnbGUpID0+XHJcbiAgICAgICAgdG9nZ2xlXHJcbiAgICAgICAgICAuc2V0VmFsdWUodGhpcy5wbHVnaW4uc2V0dGluZ3MuZW5hYmxlUmVhZGluZ1ZpZXcpXHJcbiAgICAgICAgICAub25DaGFuZ2UoYXN5bmMgKHZhbHVlKSA9PiB7XHJcbiAgICAgICAgICAgIHRoaXMucGx1Z2luLnNldHRpbmdzLmVuYWJsZVJlYWRpbmdWaWV3ID0gdmFsdWU7XHJcbiAgICAgICAgICAgIGF3YWl0IHRoaXMucGx1Z2luLnNhdmVTZXR0aW5ncygpO1xyXG4gICAgICAgICAgfSlcclxuICAgICAgKTtcclxuXHJcbiAgICBuZXcgU2V0dGluZyhjb250YWluZXJFbClcclxuICAgICAgLnNldE5hbWUoJ1Nob3cgQ2xhc3MgTGFiZWxzJylcclxuICAgICAgLnNldERlc2MoJ0Rpc3BsYXkgY2xhc3MgbmFtZXMgYWJvdmUgYmxvY2sgZWxlbWVudHMnKVxyXG4gICAgICAuYWRkVG9nZ2xlKCh0b2dnbGUpID0+XHJcbiAgICAgICAgdG9nZ2xlXHJcbiAgICAgICAgICAuc2V0VmFsdWUodGhpcy5wbHVnaW4uc2V0dGluZ3Muc2hvd0NsYXNzTGFiZWxzKVxyXG4gICAgICAgICAgLm9uQ2hhbmdlKGFzeW5jICh2YWx1ZSkgPT4ge1xyXG4gICAgICAgICAgICB0aGlzLnBsdWdpbi5zZXR0aW5ncy5zaG93Q2xhc3NMYWJlbHMgPSB2YWx1ZTtcclxuICAgICAgICAgICAgYXdhaXQgdGhpcy5wbHVnaW4uc2F2ZVNldHRpbmdzKCk7XHJcbiAgICAgICAgICAgIHRoaXMucGx1Z2luLnVwZGF0ZVN0eWxlcygpO1xyXG4gICAgICAgICAgfSlcclxuICAgICAgKTtcclxuXHJcbiAgICAvLyBDdXN0b20gQ1NTXHJcbiAgICBjb250YWluZXJFbC5jcmVhdGVFbCgnaDMnLCB7IHRleHQ6ICdDdXN0b20gQ1NTJyB9KTtcclxuICAgIFxyXG4gICAgbmV3IFNldHRpbmcoY29udGFpbmVyRWwpXHJcbiAgICAgIC5zZXROYW1lKCdBZGRpdGlvbmFsIENTUycpXHJcbiAgICAgIC5zZXREZXNjKCdBZGQgY3VzdG9tIENTUyBmb3IgeW91ciBjbGFzc2VzIChhbHNvIGFwcGxpZXMgdG8gUERGIGV4cG9ydCknKVxyXG4gICAgICAuYWRkVGV4dEFyZWEoKHRleHQpID0+IHtcclxuICAgICAgICB0ZXh0XHJcbiAgICAgICAgICAuc2V0UGxhY2Vob2xkZXIoJy5teS1jbGFzcyB7IGNvbG9yOiByZWQ7IH0nKVxyXG4gICAgICAgICAgLnNldFZhbHVlKHRoaXMucGx1Z2luLnNldHRpbmdzLmN1c3RvbUNTUylcclxuICAgICAgICAgIC5vbkNoYW5nZShhc3luYyAodmFsdWUpID0+IHtcclxuICAgICAgICAgICAgdGhpcy5wbHVnaW4uc2V0dGluZ3MuY3VzdG9tQ1NTID0gdmFsdWU7XHJcbiAgICAgICAgICAgIGF3YWl0IHRoaXMucGx1Z2luLnNhdmVTZXR0aW5ncygpO1xyXG4gICAgICAgICAgICB0aGlzLnBsdWdpbi51cGRhdGVTdHlsZXMoKTtcclxuICAgICAgICAgIH0pO1xyXG4gICAgICAgIHRleHQuaW5wdXRFbC5yb3dzID0gMTA7XHJcbiAgICAgICAgdGV4dC5pbnB1dEVsLnN0eWxlLndpZHRoID0gJzEwMCUnO1xyXG4gICAgICAgIHRleHQuaW5wdXRFbC5zdHlsZS5mb250RmFtaWx5ID0gJ3ZhcigtLWZvbnQtbW9ub3NwYWNlKSc7XHJcbiAgICAgIH0pO1xyXG5cclxuICAgIC8vIEJ1aWx0LWluIENsYXNzZXMgUmVmZXJlbmNlXHJcbiAgICBjb250YWluZXJFbC5jcmVhdGVFbCgnaDMnLCB7IHRleHQ6ICdCdWlsdC1pbiBDbGFzc2VzJyB9KTtcclxuICAgIFxyXG4gICAgY29uc3QgY2xhc3NSZWYgPSBjb250YWluZXJFbC5jcmVhdGVEaXYoKTtcclxuICAgIGNsYXNzUmVmLmlubmVySFRNTCA9IGBcclxuICAgICAgPGRpdiBzdHlsZT1cImJhY2tncm91bmQ6IHZhcigtLWJhY2tncm91bmQtc2Vjb25kYXJ5KTsgcGFkZGluZzogMWVtOyBib3JkZXItcmFkaXVzOiA4cHg7IGNvbHVtbnM6IDI7IGNvbHVtbi1nYXA6IDJlbTtcIj5cclxuICAgICAgICA8ZGl2IHN0eWxlPVwiYnJlYWstaW5zaWRlOiBhdm9pZDtcIj5cclxuICAgICAgICAgIDxoNCBzdHlsZT1cIm1hcmdpbi10b3A6IDA7XCI+Q29sb3JzPC9oND5cclxuICAgICAgICAgIDxjb2RlPnJlZCwgZ3JlZW4sIGJsdWUsIHllbGxvdywgb3JhbmdlLCBwdXJwbGUsIHBpbmssIGN5YW48L2NvZGU+XHJcbiAgICAgICAgPC9kaXY+XHJcbiAgICAgICAgPGRpdiBzdHlsZT1cImJyZWFrLWluc2lkZTogYXZvaWQ7XCI+XHJcbiAgICAgICAgICA8aDQ+QmFja2dyb3VuZHM8L2g0PlxyXG4gICAgICAgICAgPGNvZGU+YmctcmVkLCBiZy1ncmVlbiwgYmctYmx1ZSwgYmcteWVsbG93LCBiZy1vcmFuZ2UsIGJnLXB1cnBsZTwvY29kZT5cclxuICAgICAgICA8L2Rpdj5cclxuICAgICAgICA8ZGl2IHN0eWxlPVwiYnJlYWstaW5zaWRlOiBhdm9pZDtcIj5cclxuICAgICAgICAgIDxoND5DYWxsb3V0czwvaDQ+XHJcbiAgICAgICAgICA8Y29kZT53YXJuaW5nLCBkYW5nZXIsIHN1Y2Nlc3MsIGluZm8sIG5vdGUsIHRpcDwvY29kZT5cclxuICAgICAgICA8L2Rpdj5cclxuICAgICAgICA8ZGl2IHN0eWxlPVwiYnJlYWstaW5zaWRlOiBhdm9pZDtcIj5cclxuICAgICAgICAgIDxoND5UeXBvZ3JhcGh5PC9oND5cclxuICAgICAgICAgIDxjb2RlPmJvbGQsIGl0YWxpYywgdW5kZXJsaW5lLCBzdHJpa2UsIHVwcGVyY2FzZSwgbG93ZXJjYXNlPC9jb2RlPlxyXG4gICAgICAgIDwvZGl2PlxyXG4gICAgICAgIDxkaXYgc3R5bGU9XCJicmVhay1pbnNpZGU6IGF2b2lkO1wiPlxyXG4gICAgICAgICAgPGg0PlNpemVzPC9oND5cclxuICAgICAgICAgIDxjb2RlPnRleHQteHMsIHRleHQtc20sIHRleHQtbGcsIHRleHQteGwsIHRleHQtMnhsLCB0ZXh0LTN4bDwvY29kZT5cclxuICAgICAgICA8L2Rpdj5cclxuICAgICAgICA8ZGl2IHN0eWxlPVwiYnJlYWstaW5zaWRlOiBhdm9pZDtcIj5cclxuICAgICAgICAgIDxoND5IaWdobGlnaHRzPC9oND5cclxuICAgICAgICAgIDxjb2RlPmhpZ2hsaWdodCwgaGlnaGxpZ2h0LWJsdWUsIGhpZ2hsaWdodC1ncmVlbiwgaGlnaGxpZ2h0LXBpbms8L2NvZGU+XHJcbiAgICAgICAgPC9kaXY+XHJcbiAgICAgICAgPGRpdiBzdHlsZT1cImJyZWFrLWluc2lkZTogYXZvaWQ7XCI+XHJcbiAgICAgICAgICA8aDQ+Q2FyZHM8L2g0PlxyXG4gICAgICAgICAgPGNvZGU+Y2FyZCwgc2hhZG93LCBzaGFkb3ctbGcsIHJvdW5kZWQsIHJvdW5kZWQtbGc8L2NvZGU+XHJcbiAgICAgICAgPC9kaXY+XHJcbiAgICAgICAgPGRpdiBzdHlsZT1cImJyZWFrLWluc2lkZTogYXZvaWQ7XCI+XHJcbiAgICAgICAgICA8aDQ+TGF5b3V0PC9oND5cclxuICAgICAgICAgIDxjb2RlPnRleHQtbGVmdCwgdGV4dC1jZW50ZXIsIHRleHQtcmlnaHQsIGNvbHVtbnMtMiwgY29sdW1ucy0zPC9jb2RlPlxyXG4gICAgICAgIDwvZGl2PlxyXG4gICAgICA8L2Rpdj5cclxuICAgIGA7XHJcbiAgfVxyXG59Il0sCiAgIm1hcHBpbmdzIjogIjs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7O0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUlBLElBQUFBLG1CQUF1Qjs7O0FDQ3ZCLGtCQU1PO0FBQ1AsbUJBQTJDO0FBRzNDLElBQU0sV0FBVztBQUFBO0FBQUEs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
